---
phase: 12-annas-archive
plan: 02
type: tdd
wave: 2
depends_on: ["12-01"]
files_modified:
  - lib/sources/annas.py
  - __tests__/python/test_annas_adapter.py
autonomous: true

must_haves:
  truths:
    - "Anna's Archive search returns UnifiedBookResult list with source=ANNAS_ARCHIVE"
    - "Anna's Archive fast download API returns DownloadResult with working URL using domain_index=1"
    - "Quota tracking extracts downloads_left from API response"
    - "Search scraping extracts MD5 hashes from HTML"
  artifacts:
    - path: "lib/sources/annas.py"
      provides: "AnnasArchiveAdapter implementing SourceAdapter"
      exports: ["AnnasArchiveAdapter"]
      min_lines: 80
    - path: "__tests__/python/test_annas_adapter.py"
      provides: "TDD tests for Anna's Archive adapter"
      contains: "test_search_returns_results"
  key_links:
    - from: "lib/sources/annas.py"
      to: "httpx.AsyncClient"
      via: "HTTP requests for search and API"
      pattern: "httpx.AsyncClient"
    - from: "lib/sources/annas.py"
      to: "lib/sources/models.py"
      via: "Returns UnifiedBookResult and DownloadResult"
      pattern: "from .models import"
---

<objective>
Create Anna's Archive source adapter with HTML search scraping and fast download API.

Purpose: Enable searching Anna's Archive and downloading books via the user's paid API key. This is the PRIMARY source for book downloads.
Output: lib/sources/annas.py with AnnasArchiveAdapter class passing TDD tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-annas-archive/12-CONTEXT.md
@.planning/phases/12-annas-archive/12-RESEARCH.md
@.planning/phases/12-annas-archive/12-EXPERIMENT.md
@.planning/phases/12-annas-archive/12-01-SUMMARY.md
</context>

<feature>
  <name>Anna's Archive Adapter</name>
  <files>lib/sources/annas.py, __tests__/python/test_annas_adapter.py</files>
  <behavior>
AnnasArchiveAdapter provides:

1. search(query) -> List[UnifiedBookResult]:
   - Scrapes HTML from /search?q={query}
   - Extracts MD5 hashes using selector: a[href^='/md5/']
   - Deduplicates results
   - Returns UnifiedBookResult with source=SourceType.ANNAS_ARCHIVE

2. get_download_url(md5) -> DownloadResult:
   - Calls /dyn/api/fast_download.json?md5={md5}&key={key}&domain_index=1
   - CRITICAL: Must use domain_index=1 (domain_index=0 has SSL errors)
   - Returns download_url from response
   - Extracts quota info: downloads_left, downloads_per_day, downloads_done_today
   - Raises exception if API returns error or no download_url

Test cases (inputs -> expected outputs):
- search("python programming") -> List with at least 1 UnifiedBookResult
- search("nonexistent_book_xyz123") -> Empty list (no results)
- get_download_url("validmd5") -> DownloadResult with url and quota_info
- get_download_url("invalidmd5") -> Exception raised
  </behavior>
  <implementation>
```python
import httpx
from bs4 import BeautifulSoup
from urllib.parse import quote
from typing import List, Optional
from .models import UnifiedBookResult, DownloadResult, QuotaInfo, SourceType
from .base import SourceAdapter
from .config import SourceConfig

class QuotaExhaustedError(Exception):
    """Raised when Anna's Archive download quota is exhausted."""
    pass

class AnnasArchiveAdapter(SourceAdapter):
    def __init__(self, config: SourceConfig):
        self.config = config
        self.base_url = config.annas_base_url.rstrip('/')
        self.secret_key = config.annas_secret_key
        self._client: Optional[httpx.AsyncClient] = None

    async def _get_client(self) -> httpx.AsyncClient:
        if self._client is None:
            self._client = httpx.AsyncClient(timeout=30, follow_redirects=True)
        return self._client

    async def search(self, query: str, **kwargs) -> List[UnifiedBookResult]:
        client = await self._get_client()
        url = f"{self.base_url}/search?q={quote(query)}"
        response = await client.get(url)
        response.raise_for_status()

        soup = BeautifulSoup(response.text, 'html.parser')
        results = []
        seen = set()

        for link in soup.select("a[href^='/md5/']"):
            md5 = link.get('href', '').split('/')[-1]
            if md5 and md5 not in seen:
                seen.add(md5)
                results.append(UnifiedBookResult(
                    md5=md5,
                    title=link.get_text(strip=True) or "Unknown",
                    source=SourceType.ANNAS_ARCHIVE,
                    extra={"url": f"{self.base_url}/md5/{md5}"},
                ))
        return results

    async def get_download_url(self, md5: str) -> DownloadResult:
        if not self.secret_key:
            raise ValueError("ANNAS_SECRET_KEY not configured")

        client = await self._get_client()
        url = f"{self.base_url}/dyn/api/fast_download.json"
        params = {
            "md5": md5,
            "key": self.secret_key,
            "domain_index": 1,  # CRITICAL: Use 1, not 0
        }

        response = await client.get(url, params=params)
        response.raise_for_status()
        data = response.json()

        if data.get("error"):
            raise Exception(f"Anna's Archive API error: {data['error']}")

        download_url = data.get("download_url")
        if not download_url:
            raise Exception("No download_url in response")

        quota_info = None
        account_info = data.get("account_fast_download_info")
        if account_info:
            quota_info = QuotaInfo(
                downloads_left=account_info.get("downloads_left", 0),
                downloads_per_day=account_info.get("downloads_per_day", 0),
                downloads_done_today=account_info.get("downloads_done_today", 0),
            )

        return DownloadResult(
            url=download_url,
            source=SourceType.ANNAS_ARCHIVE,
            quota_info=quota_info,
        )

    async def close(self) -> None:
        if self._client:
            await self._client.aclose()
            self._client = None
```
  </implementation>
</feature>

<verification>
```bash
# Run TDD tests
cd /home/rookslog/workspace/projects/zlibrary-mcp && uv run pytest __tests__/python/test_annas_adapter.py -v

# Quick integration check (requires ANNAS_SECRET_KEY)
cd /home/rookslog/workspace/projects/zlibrary-mcp && uv run python -c "
import asyncio
from lib.sources.annas import AnnasArchiveAdapter
from lib.sources.config import get_source_config

async def test():
    config = get_source_config()
    adapter = AnnasArchiveAdapter(config)
    try:
        results = await adapter.search('python')
        print(f'Search returned {len(results)} results')
        if results:
            print(f'First: {results[0].md5[:8]}... {results[0].title[:40]}')
    finally:
        await adapter.close()

asyncio.run(test())
"
```
</verification>

<success_criteria>
1. AnnasArchiveAdapter implements SourceAdapter interface
2. search() returns List[UnifiedBookResult] with source=ANNAS_ARCHIVE
3. get_download_url() returns DownloadResult with working URL
4. get_download_url() uses domain_index=1 (not 0)
5. QuotaInfo populated from API response
6. TDD tests pass for search and download
</success_criteria>

<output>
After completion, create `.planning/phases/12-annas-archive/12-02-SUMMARY.md`
</output>
