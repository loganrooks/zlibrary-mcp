---
phase: 06-documentation-quality-gates
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - .husky/pre-commit
  - .github/workflows/ci.yml
  - setup-uv.sh
  - .claude/CI_CD.md
autonomous: true

must_haves:
  truths:
    - "Running git commit triggers lint-staged via husky pre-commit hook (lint on changed files only; tests run in CI, not pre-commit — Jest ESM is too slow for hooks)"
    - "lint-staged runs ruff on .py files and TypeScript build check on .ts files"
    - "CI pipeline runs npm test, uv run pytest, npm audit, and uv run pip-audit"
    - "setup-uv.sh checks Python version >= 3.10 before proceeding"
    - "CI_CD.md documents the actual CI pipeline (not a planned one)"
  artifacts:
    - path: ".husky/pre-commit"
      provides: "Git pre-commit hook running lint-staged"
    - path: ".github/workflows/ci.yml"
      provides: "GitHub Actions CI pipeline"
    - path: "setup-uv.sh"
      provides: "Setup script with Python version check"
    - path: ".claude/CI_CD.md"
      provides: "Accurate CI/CD documentation"
  key_links:
    - from: ".husky/pre-commit"
      to: "lint-staged config in package.json"
      via: "npx lint-staged"
      pattern: "lint-staged"
    - from: ".github/workflows/ci.yml"
      to: "npm test + uv run pytest"
      via: "GitHub Actions steps"
      pattern: "npm test|uv run pytest"
    - from: "setup-uv.sh"
      to: "Python version check"
      via: "exit 1 on version mismatch"
      pattern: "exit 1"
---

<objective>
Install pre-commit hooks (Husky + lint-staged), create GitHub Actions CI pipeline with security auditing, add Python version check to setup script, and update CI_CD.md to reflect reality.

Purpose: Quality gates prevent future drift — hooks catch issues at commit time, CI catches them at push time.
Output: Working pre-commit hooks, CI pipeline file, updated setup script, accurate CI_CD.md.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-documentation-quality-gates/06-RESEARCH.md
@package.json
@setup-uv.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Husky + lint-staged pre-commit hooks</name>
  <files>
    package.json
    .husky/pre-commit
  </files>
  <action>
1. Install dev dependencies: `npm install --save-dev husky lint-staged`
2. Add to pyproject.toml dev deps: `uv add --dev ruff` (for Python linting in hooks)
3. Run `npx husky init` to create `.husky/` directory
4. Edit `.husky/pre-commit` to contain just: `npx lint-staged`
5. Add `"prepare": "husky"` to package.json scripts (husky init may do this)
6. Add lint-staged config to package.json:
```json
"lint-staged": {
  "*.{ts,js}": "npm run build",
  "*.py": ["uv run ruff check --fix", "uv run ruff format"]
}
```

**Notes:**
- Do NOT include Jest in pre-commit hooks (too slow with ESM experimental modules). Full tests run in CI.
- Do NOT add prettier — project doesn't use it currently and adding it would reformat all files.
- Use `"prepare": "husky || true"` so CI environments don't fail when husky isn't needed.
- The `npm run build` for TS files does TypeScript compilation check (catches type errors).
  </action>
  <verify>
Test the hook works:
```bash
# Create a test file to stage
echo "# test" > /tmp/test-hook.md
cp /tmp/test-hook.md test-hook-temp.md
git add test-hook-temp.md
git commit -m "test: verify pre-commit hook" --dry-run
# Clean up
git reset HEAD test-hook-temp.md
rm test-hook-temp.md
```
Verify files exist:
- `cat .husky/pre-commit` shows `npx lint-staged`
- `grep "prepare" package.json` shows husky
- `grep "lint-staged" package.json` shows config
  </verify>
  <done>Pre-commit hook installed: git commit triggers lint-staged which runs TypeScript build check on .ts/.js and ruff on .py files.</done>
</task>

<task type="auto">
  <name>Task 2: Create CI pipeline and update setup script</name>
  <files>
    .github/workflows/ci.yml
    setup-uv.sh
    .claude/CI_CD.md
  </files>
  <action>
**GitHub Actions CI** — Create `.github/workflows/ci.yml`:
```yaml
name: CI
on:
  push:
    branches: [master]
  pull_request:
    branches: [master]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
      - uses: astral-sh/setup-uv@v4
      - run: npm ci
      - run: uv sync
      - run: npm run build
      - run: node --experimental-vm-modules node_modules/jest/bin/jest.js
      - run: uv run pytest

  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
      - uses: astral-sh/setup-uv@v4
      - run: npm ci
      - run: uv sync
      - run: npm audit --omit=dev --audit-level=high
      - run: uv run pip-audit || true
```

**Notes:**
- `npm audit --omit=dev` avoids noise from dev dep vulnerabilities
- `--audit-level=high` filters moderate findings
- `uv run pip-audit || true` because vendored zlibrary fork may trigger false positives (see Research pitfall 4)
- No Z-Library credentials in CI — unit tests only, no integration/live tests
- Single Node 18 (LTS), no matrix — MCP server doesn't need multi-version testing

**Setup script Python version check** — Add to top of `setup-uv.sh` (after shebang):
```bash
# Check Python version
PYTHON_VERSION=$(python3 --version 2>&1 | grep -oP '\d+\.\d+')
REQUIRED="3.10"
if [ "$(printf '%s\n' "$REQUIRED" "$PYTHON_VERSION" | sort -V | head -n1)" != "$REQUIRED" ]; then
    echo "Error: Python $REQUIRED+ required, found $PYTHON_VERSION"
    exit 1
fi
echo "Python $PYTHON_VERSION detected (>= $REQUIRED required)"
```

**CI_CD.md** — Rewrite `.claude/CI_CD.md` to document the ACTUAL CI pipeline (not planned). Reference the real `.github/workflows/ci.yml` file. Add `<!-- Last Verified: 2026-02-01 -->`. Document: triggers, jobs (test + audit), pre-commit hooks (husky + lint-staged), and how to bypass hooks with `--no-verify`.
  </action>
  <verify>
```bash
# Verify CI file is valid YAML
python3 -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml'))" 2>/dev/null || echo "Install pyyaml or manually check YAML syntax"
# Verify files exist
ls .github/workflows/ci.yml
grep "sort -V" setup-uv.sh
grep "Last Verified" .claude/CI_CD.md
```
  </verify>
  <done>CI pipeline exists at .github/workflows/ci.yml with test + audit jobs. setup-uv.sh checks Python >= 3.10. CI_CD.md documents actual (not planned) infrastructure.</done>
</task>

</tasks>

<verification>
1. `.husky/pre-commit` exists and contains `npx lint-staged`
2. `package.json` has lint-staged config and prepare script
3. `.github/workflows/ci.yml` exists with test and audit jobs
4. `setup-uv.sh` has Python version check at top
5. `.claude/CI_CD.md` references actual CI file, has Last Verified timestamp
6. `grep -r "npm audit" .github/workflows/ci.yml` finds audit step
7. `grep -r "pip-audit" .github/workflows/ci.yml` finds pip-audit step
</verification>

<success_criteria>
Quality gates are installed: pre-commit hooks catch lint/type issues at commit time, CI pipeline catches test failures and security vulnerabilities at push/PR time, setup script validates Python version. CI_CD.md accurately documents reality.
</success_criteria>

<output>
After completion, create `.planning/phases/06-documentation-quality-gates/06-02-SUMMARY.md`
</output>
