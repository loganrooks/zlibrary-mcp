---
phase: 01-integration-test-harness
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - Dockerfile.test
  - docker-compose.test.yml
  - .dockerignore
  - __tests__/e2e/docker-mcp-e2e.test.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "A Docker-based E2E test starts the MCP server, calls at least one tool, and receives a structured response"
    - "`npm run test:e2e` builds and runs the Docker E2E test to completion"
    - "Docker image supports both amd64 and arm64 platforms"
    - "E2E test uses MCP SDK Client with StdioClientTransport to call the server programmatically"
  artifacts:
    - path: "Dockerfile.test"
      provides: "Test-only Docker image with Node.js, Python, UV, and built MCP server"
      contains: "uv sync"
    - path: "__tests__/e2e/docker-mcp-e2e.test.js"
      provides: "E2E test using MCP SDK Client to call server inside Docker"
      min_lines: 40
    - path: "docker-compose.test.yml"
      provides: "Docker Compose orchestration for E2E test"
      contains: "Dockerfile.test"
    - path: ".dockerignore"
      provides: "Excludes node_modules, .venv, downloads, .git from build context"
      contains: "node_modules"
  key_links:
    - from: "__tests__/e2e/docker-mcp-e2e.test.js"
      to: "dist/index.js"
      via: "MCP SDK StdioClientTransport spawning the server"
      pattern: "StdioClientTransport"
    - from: "Dockerfile.test"
      to: "pyproject.toml"
      via: "uv sync to install Python dependencies"
      pattern: "uv sync"
    - from: "package.json"
      to: "docker-compose.test.yml"
      via: "test:e2e npm script"
      pattern: "test:e2e"
---

<objective>
Create a Docker-based E2E test that builds the MCP server in a container, starts it, and verifies tool invocation via the MCP SDK Client.

Purpose: Proves the full stack (Node.js + Python + vendored zlibrary) works in a clean environment, catching dependency or build issues that local dev misses.
Output: Dockerfile.test, docker-compose.test.yml, .dockerignore, docker-mcp-e2e.test.js, updated npm scripts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-integration-test-harness/01-RESEARCH.md
@.planning/phases/01-integration-test-harness/01-01-SUMMARY.md

Key reference files:
@src/index.ts                      — MCP server entry point
@pyproject.toml                    — Python dependencies
@tsconfig.json                     — TypeScript build config
@package.json                      — Node dependencies and scripts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dockerfile.test, .dockerignore, and docker-compose.test.yml</name>
  <files>
    Dockerfile.test
    .dockerignore
    docker-compose.test.yml
  </files>
  <action>
1. Create `.dockerignore` excluding: `node_modules/`, `.venv/`, `downloads/`, `processed_rag_output/`, `coverage/`, `.git/`, `*.md` (except package files), `.planning/`, `claudedocs/`.

2. Create `Dockerfile.test` (multi-stage, multi-platform compatible):
   - Base: `node:20-slim`
   - Install Python 3 and venv: `apt-get update && apt-get install -y python3 python3-venv && rm -rf /var/lib/apt/lists/*`
   - Copy UV binary: `COPY --from=ghcr.io/astral-sh/uv:latest /uv /usr/local/bin/uv`
   - Python deps layer: COPY `pyproject.toml`, `uv.lock`, `zlibrary/`, `lib/` → `uv sync`
   - Node deps layer: COPY `package.json`, `package-lock.json` → `npm ci`
   - Build layer: COPY `src/`, `tsconfig.json` → `npm run build`
   - Test layer: COPY `__tests__/e2e/`, `jest.config.js`
   - CMD: run E2E tests via Jest
   - Important: ensure `.venv/` is created in `/app` so `venv-manager.ts` finds it

3. Create `docker-compose.test.yml`:
   - Service: `e2e-test`
   - Build context: `.` with `Dockerfile.test`
   - Environment: `ZLIBRARY_EMAIL`, `ZLIBRARY_PASSWORD`, `ZLIBRARY_MIRROR` (optional, from host env)
   - No ports needed (stdio-based)
   - Exit code propagation: the compose run should exit non-zero if tests fail

4. Test the Docker build locally: `docker build -f Dockerfile.test -t zlibrary-mcp-test .`
   - Verify it completes without errors
   - Verify `node dist/index.js` starts inside the container (quick smoke: `docker run --rm zlibrary-mcp-test node -e "require('./dist/index.js')"` or equivalent)
  </action>
  <verify>
`docker build -f Dockerfile.test -t zlibrary-mcp-test .` completes successfully. Container has both `node` and `python3` available. `ls /app/.venv/bin/python` exists inside the container.
  </verify>
  <done>
Dockerfile.test builds a working image with Node.js, Python, UV, all dependencies installed, and the MCP server built. .dockerignore keeps build context small. docker-compose.test.yml orchestrates E2E runs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create E2E test and wire npm scripts</name>
  <files>
    __tests__/e2e/docker-mcp-e2e.test.js
    package.json
  </files>
  <action>
1. Create `__tests__/e2e/docker-mcp-e2e.test.js` using the MCP SDK Client:

```javascript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
```

2. Test cases:
   a. **listTools**: Connect to server, call `client.listTools()`, verify it returns exactly 11 tools with expected names. This test requires NO credentials.
   b. **callTool (if credentials available)**: If `ZLIBRARY_EMAIL` and `ZLIBRARY_PASSWORD` are set, call `get_download_limits` tool and verify it returns a structured response with `content` array. If no credentials, skip with clear message.

3. Setup/teardown:
   - `beforeAll`: Create `StdioClientTransport` spawning `node dist/index.js`, create `Client`, connect
   - `afterAll`: Close client and transport, ensure child process is killed
   - Timeout: 30s for connection, 60s for tool calls

4. The E2E test runs INSIDE the Docker container (not from host connecting to container). The Dockerfile CMD runs Jest targeting the `e2e` directory.

5. Add npm scripts to `package.json`:
   - `"test:e2e": "docker compose -f docker-compose.test.yml up --build --abort-on-container-exit --exit-code-from e2e-test"`
   - `"test:e2e:local": "node --experimental-vm-modules node_modules/jest/bin/jest.js --testPathPattern 'e2e' --forceExit"` (for running without Docker)

6. Run `npm run test:e2e` to verify the full Docker E2E pipeline.
  </action>
  <verify>
`npm run test:e2e` builds the Docker image, runs E2E tests inside, and exits 0. The listTools test confirms 11 tools are registered. If credentials are available, the callTool test also passes.
  </verify>
  <done>
Docker E2E test proves the MCP server starts, responds to listTools with 11 tools, and (with credentials) successfully handles a tool call. `npm run test:e2e` is a single command that runs the full pipeline.
  </done>
</task>

</tasks>

<verification>
1. `docker build -f Dockerfile.test .` completes without errors
2. `npm run test:e2e` exits 0 with listTools test passing
3. `npm run test:e2e:local` runs E2E tests without Docker (for local dev)
4. Docker image is under 1GB and builds in under 5 minutes
5. No regressions: `npm test` still passes
</verification>

<success_criteria>
- `npm run test:e2e` exits 0 with at least the listTools E2E test passing
- Docker image contains working Node.js + Python + UV environment
- MCP server starts and responds to protocol requests inside Docker
- Multi-platform Dockerfile (no platform-specific commands)
</success_criteria>

<output>
After completion, create `.planning/phases/01-integration-test-harness/01-02-SUMMARY.md`
</output>
