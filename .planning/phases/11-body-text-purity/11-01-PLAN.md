---
phase: 11-body-text-purity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/rag/pipeline/__init__.py
  - lib/rag/pipeline/models.py
  - lib/rag/detection/registry.py
autonomous: true

must_haves:
  truths:
    - "ContentType enum covers all 11 content types (body, footnote, endnote, margin, heading, page_number, toc, front_matter, header, footer, citation)"
    - "BlockClassification dataclass holds bbox, content_type, text, confidence, detector_name, metadata"
    - "DetectionResult dataclass holds detector_name, classifications list, page_num, metadata"
    - "DocumentOutput dataclass holds body_text, footnotes, endnotes, citations, metadata fields"
    - "Detector registry supports decorator-based registration with priority ordering"
    - "get_registered_detectors() returns detectors sorted by priority (lower runs first)"
  artifacts:
    - path: "lib/rag/pipeline/models.py"
      provides: "ContentType, BlockClassification, DetectionResult, DocumentOutput dataclasses"
      contains: "class ContentType"
    - path: "lib/rag/detection/registry.py"
      provides: "register_detector decorator, get_registered_detectors, DetectorScope enum"
      contains: "register_detector"
    - path: "lib/rag/pipeline/__init__.py"
      provides: "Package init with public exports"
  key_links:
    - from: "lib/rag/detection/registry.py"
      to: "lib/rag/pipeline/models.py"
      via: "imports ContentType, BlockClassification, DetectionResult"
      pattern: "from.*pipeline.*models.*import"
---

<objective>
Create the data model foundation and detector registry for the unified detection pipeline.

Purpose: All subsequent plans depend on these types and the registry pattern. This establishes the contract between detectors, compositor, and writer.
Output: `lib/rag/pipeline/models.py` (data models), `lib/rag/detection/registry.py` (registry), `lib/rag/pipeline/__init__.py` (package init)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-body-text-purity/11-RESEARCH.md
@lib/rag_data_models.py
@lib/rag/detection/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pipeline data models</name>
  <files>lib/rag/pipeline/__init__.py, lib/rag/pipeline/models.py</files>
  <action>
Create `lib/rag/pipeline/` package with `__init__.py` and `models.py`.

In `models.py`, define:

1. `ContentType(Enum)` with values: BODY, FOOTNOTE, ENDNOTE, MARGIN, HEADING, PAGE_NUMBER, TOC, FRONT_MATTER, HEADER, FOOTER, CITATION

2. `DetectorScope(Enum)` with values: PAGE (page-level like footnotes/margins) and DOCUMENT (document-level like TOC/headings/page_numbers/front_matter)

3. `BlockClassification` dataclass:
   - `bbox: Tuple[float, float, float, float]` (x0, y0, x1, y1)
   - `content_type: ContentType`
   - `text: str`
   - `confidence: float` (0.0-1.0, default 1.0)
   - `detector_name: str`
   - `page_num: int` (1-indexed)
   - `metadata: Dict[str, Any]` (default_factory=dict)

4. `DetectionResult` dataclass:
   - `detector_name: str`
   - `classifications: List[BlockClassification]`
   - `page_num: int` (1-indexed, 0 for document-level)
   - `metadata: Dict[str, Any]` (default_factory=dict)

5. `DocumentOutput` dataclass:
   - `body_text: str`
   - `footnotes: Optional[str]` (None if no footnotes)
   - `endnotes: Optional[str]` (None if no endnotes)
   - `citations: Optional[str]` (None if no citations)
   - `document_metadata: Optional[dict]` (TOC structure, front matter, title — always populated)
   - `processing_metadata: Optional[dict]` (per-block classifications, confidence — optional)
   - `write_files(base_path: Path, output_format: str = "markdown") -> Dict[str, Path]` method that writes body as `{stem}.md`, footnotes as `{stem}_footnotes.md` (if non-empty), endnotes as `{stem}_endnotes.md` (if non-empty), citations as `{stem}_citations.md` (if non-empty), metadata as `{stem}_meta.json` (always). Returns dict mapping content type to written file path.

In `__init__.py`, export all public types: ContentType, DetectorScope, BlockClassification, DetectionResult, DocumentOutput.

Use stdlib only (dataclasses, enum, typing, pathlib, json). No external dependencies.
  </action>
  <verify>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp
uv run python -c "
from lib.rag.pipeline.models import ContentType, DetectorScope, BlockClassification, DetectionResult, DocumentOutput
assert len(ContentType) == 11
assert DetectorScope.PAGE.value == 'page'
b = BlockClassification(bbox=(0,0,1,1), content_type=ContentType.FOOTNOTE, text='test', confidence=0.9, detector_name='test', page_num=1)
assert b.confidence == 0.9
d = DetectionResult(detector_name='test', classifications=[b], page_num=1)
assert len(d.classifications) == 1
o = DocumentOutput(body_text='hello')
assert o.footnotes is None
print('All model checks passed')
"
```
  </verify>
  <done>All 5 data models importable and functional with correct fields and defaults</done>
</task>

<task type="auto">
  <name>Task 2: Create detector registry</name>
  <files>lib/rag/detection/registry.py</files>
  <action>
Create `lib/rag/detection/registry.py` with:

1. `_DETECTOR_REGISTRY: Dict[str, dict]` — module-level registry dict

2. `register_detector(name: str, priority: int = 50, scope: DetectorScope = DetectorScope.PAGE)` decorator:
   - Registers the decorated function in `_DETECTOR_REGISTRY` with keys: `func`, `priority`, `scope`, `name`
   - Returns the original function unmodified
   - Raises ValueError if name already registered (duplicate guard)

3. `get_registered_detectors(scope: Optional[DetectorScope] = None) -> List[dict]`:
   - Returns all registered detectors sorted by priority (ascending, lower = runs first)
   - If `scope` provided, filters to only that scope
   - Each entry has keys: `func`, `priority`, `scope`, `name`

4. `clear_registry()` — for testing only, clears `_DETECTOR_REGISTRY`

Import types from `lib.rag.pipeline.models`. Keep registry under 80 lines. Do NOT add dynamic module loading, config files, or complex lifecycle management — just a simple decorator + dict pattern.
  </action>
  <verify>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp
uv run python -c "
from lib.rag.detection.registry import register_detector, get_registered_detectors, clear_registry
from lib.rag.pipeline.models import DetectorScope

clear_registry()

@register_detector('test_a', priority=20, scope=DetectorScope.PAGE)
def detector_a(page, page_num, context): pass

@register_detector('test_b', priority=10, scope=DetectorScope.DOCUMENT)
def detector_b(doc, context): pass

all_d = get_registered_detectors()
assert len(all_d) == 2
assert all_d[0]['name'] == 'test_b'  # priority 10 first

page_d = get_registered_detectors(scope=DetectorScope.PAGE)
assert len(page_d) == 1
assert page_d[0]['name'] == 'test_a'

clear_registry()
assert len(get_registered_detectors()) == 0
print('Registry checks passed')
"
```
  </verify>
  <done>Decorator registry functional with priority sorting, scope filtering, duplicate guard, and clear_registry for tests</done>
</task>

</tasks>

<verification>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp
# All imports work
uv run python -c "from lib.rag.pipeline import ContentType, DetectorScope, BlockClassification, DetectionResult, DocumentOutput; print('Pipeline package imports OK')"
uv run python -c "from lib.rag.detection.registry import register_detector, get_registered_detectors; print('Registry imports OK')"
```
</verification>

<success_criteria>
- All 5 data models (ContentType, DetectorScope, BlockClassification, DetectionResult, DocumentOutput) importable and fully typed
- Registry decorator registers functions with priority and scope
- get_registered_detectors returns sorted list, supports scope filtering
- DocumentOutput.write_files produces correct file suffixes
- No external dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/11-body-text-purity/11-01-SUMMARY.md`
</output>
