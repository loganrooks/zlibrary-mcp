---
phase: 10-adaptive-resolution
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/rag/resolution/__init__.py
  - lib/rag/resolution/models.py
  - lib/rag/resolution/analyzer.py
  - __tests__/python/test_resolution_analyzer.py
autonomous: true

must_haves:
  truths:
    - "compute_optimal_dpi returns correct DPI for common font sizes (5-12pt)"
    - "DPI is quantized to multiples of 50"
    - "DPI is clamped between floor (72) and ceiling (600)"
    - "Page font analysis extracts dominant, min, max sizes from text dict"
    - "Pages with no text layer return fallback DPI 300 with confidence 0"
    - "Mixed-size pages flag has_small_text when min < 70% of dominant"
  artifacts:
    - path: "lib/rag/resolution/models.py"
      provides: "DPIDecision, PageAnalysis, RegionDPI dataclasses"
      contains: "class DPIDecision"
    - path: "lib/rag/resolution/analyzer.py"
      provides: "compute_optimal_dpi, analyze_page_fonts, analyze_document_fonts"
      exports: ["compute_optimal_dpi", "analyze_page_fonts", "analyze_document_fonts"]
    - path: "__tests__/python/test_resolution_analyzer.py"
      provides: "Unit tests for DPI computation and font analysis"
  key_links:
    - from: "lib/rag/resolution/analyzer.py"
      to: "lib/rag/resolution/models.py"
      via: "imports DPIDecision, PageAnalysis"
      pattern: "from.*models import.*DPIDecision"
---

<objective>
Create the adaptive resolution data models and font analysis engine with TDD.

Purpose: Foundation for adaptive DPI — the math and analysis that drives all DPI decisions. Pure computation with clear inputs/outputs, ideal for TDD.
Output: `lib/rag/resolution/` package with models.py and analyzer.py, fully tested.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-adaptive-resolution/10-RESEARCH.md
@lib/rag/ocr/recovery.py
</context>

<feature>
  <name>DPI Computation and Font Analysis Engine</name>
  <files>
    lib/rag/resolution/__init__.py
    lib/rag/resolution/models.py
    lib/rag/resolution/analyzer.py
    __tests__/python/test_resolution_analyzer.py
  </files>
  <behavior>
    DPI computation from font size:
    - compute_optimal_dpi(12.0) → DPIDecision(dpi=150, confidence=1.0, ...)
    - compute_optimal_dpi(10.0) → DPIDecision(dpi=200, confidence=1.0, ...)
    - compute_optimal_dpi(7.0) → DPIDecision(dpi=300, confidence=1.0, ...)
    - compute_optimal_dpi(5.0) → DPIDecision(dpi=400, confidence=1.0, ...)
    - compute_optimal_dpi(0) → DPIDecision(dpi=300, confidence=0.0, reason="invalid_font_size")
    - compute_optimal_dpi(1.0) → dpi clamped to ceiling, confidence < 1.0

    Formula: optimal_dpi = TARGET_PIXEL_HEIGHT_IDEAL * 72 / font_size_pt
    Then quantize to nearest 50, clamp to [72, 600].
    Full-page DPI capped at 300; region DPI capped at 600.

    Constants:
    - DPI_FLOOR = 72, DPI_CEILING = 600, DPI_PAGE_CAP = 300, DPI_DEFAULT = 300
    - TARGET_PIXEL_HEIGHT_MIN = 20, TARGET_PIXEL_HEIGHT_MAX = 33, TARGET_PIXEL_HEIGHT_IDEAL = 28

    Models (dataclasses):
    - DPIDecision: dpi, confidence, reason, font_size_pt, estimated_pixel_height
    - RegionDPI: bbox (tuple of 4 floats), dpi_decision (DPIDecision), region_type (str)
    - PageAnalysis: page_num, dominant_size, min_size, max_size, has_small_text, page_dpi (DPIDecision), regions (list[RegionDPI])

    Page font analysis (analyze_page_fonts):
    - Takes a fitz.Page, returns PageAnalysis
    - Extracts font sizes from page.get_text("dict") spans
    - Dominant = median of all span sizes
    - has_small_text = min_size < dominant * 0.7
    - Calls compute_optimal_dpi(dominant_size) for page_dpi
    - Empty pages → dominant_size=0, page_dpi=DPI_DEFAULT, confidence=0

    Document analysis (analyze_document_fonts):
    - Takes pdf_path (str) and optional page_range
    - Opens document, analyzes each page
    - Returns dict[int, PageAnalysis] keyed by page number
    - Uses ProcessPoolExecutor for documents with >10 pages
    - Workers receive pdf_path (not fitz objects — not picklable)

    Scanned PDF handling:
    - If page has no text spans → return fallback PageAnalysis with dpi=300, confidence=0, reason="no_text_layer"
  </behavior>
  <implementation>
    1. Create lib/rag/resolution/__init__.py with public exports
    2. Create models.py with DPIDecision, RegionDPI, PageAnalysis dataclasses
    3. Create analyzer.py with compute_optimal_dpi, analyze_page_fonts, analyze_document_fonts
    4. Follow research RESEARCH.md patterns exactly for DPI formula and quantization
    5. Use ProcessPoolExecutor pattern from lib/rag/xmark/detection.py for parallel analysis
    6. For analyze_page_fonts, use page.get_text("dict") to extract spans — do NOT render
  </implementation>
</feature>

<verification>
```bash
# Run tests
cd /home/rookslog/workspace/projects/zlibrary-mcp && uv run pytest __tests__/python/test_resolution_analyzer.py -v

# Verify module imports
uv run python -c "from lib.rag.resolution.models import DPIDecision, RegionDPI, PageAnalysis; print('Models OK')"
uv run python -c "from lib.rag.resolution.analyzer import compute_optimal_dpi, analyze_page_fonts; print('Analyzer OK')"
```
</verification>

<success_criteria>
- All unit tests pass for compute_optimal_dpi across font sizes 1-20pt
- analyze_page_fonts correctly extracts dominant/min/max from mock page data
- DPI quantization produces multiples of 50
- DPI clamping respects floor (72) and ceiling (600)
- Scanned PDF fallback returns DPI_DEFAULT with confidence 0
- ProcessPoolExecutor pattern works for multi-page analysis
</success_criteria>

<output>
After completion, create `.planning/phases/10-adaptive-resolution/10-01-SUMMARY.md`
</output>
