---
phase: 11-body-text-purity
plan: 06
type: execute
wave: 4
depends_on: ["11-05"]
files_modified:
  - lib/rag/orchestrator_pdf.py
  - lib/rag/orchestrator.py
autonomous: true

must_haves:
  truths:
    - "process_pdf() returns single string (backward compatible, identical behavior to before Phase 11)"
    - "process_pdf_structured() returns DocumentOutput with multi-file output"
    - "process_document() in orchestrator.py calls process_pdf_structured() and writes multiple output files"
    - "MCP tool response includes footnotes_file_path and metadata_file_path when available"
    - "Existing tests pass without modification (backward compat preserved)"
  artifacts:
    - path: "lib/rag/orchestrator_pdf.py"
      provides: "process_pdf_structured() using pipeline runner; process_pdf() backward compat wrapper"
      contains: "def process_pdf_structured"
    - path: "lib/rag/orchestrator.py"
      provides: "Updated process_document() that saves multi-file output"
      contains: "write_files"
  key_links:
    - from: "lib/rag/orchestrator_pdf.py"
      to: "lib/rag/pipeline/runner.py"
      via: "run_document_pipeline(doc)"
      pattern: "run_document_pipeline"
    - from: "lib/rag/orchestrator.py"
      to: "lib/rag/orchestrator_pdf.py"
      via: "calls process_pdf_structured()"
      pattern: "process_pdf_structured"
    - from: "lib/rag/orchestrator_pdf.py"
      to: "lib/rag/orchestrator_pdf.py"
      via: "process_pdf() wraps process_pdf_structured().body_text"
      pattern: "process_pdf_structured"
---

<objective>
Refactor orchestrator_pdf.py to use the new pipeline and wire multi-file output through orchestrator.py to the MCP layer.

Purpose: This is the integration point where the new pipeline replaces the monolith. Backward compatibility is critical — process_pdf() must return identical output to current behavior.
Output: Refactored orchestrator_pdf.py with process_pdf_structured(), updated orchestrator.py with multi-file saving
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-body-text-purity/11-RESEARCH.md
@.planning/phases/11-body-text-purity/11-01-SUMMARY.md
@.planning/phases/11-body-text-purity/11-05-SUMMARY.md
@lib/rag/orchestrator_pdf.py
@lib/rag/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add process_pdf_structured() to orchestrator_pdf.py</name>
  <files>lib/rag/orchestrator_pdf.py</files>
  <action>
Add a new function `process_pdf_structured()` to `orchestrator_pdf.py`:

```python
def process_pdf_structured(
    file_path: str,
    output_format: str = "markdown",
    include_metadata: bool = False
) -> DocumentOutput:
    """Process PDF using unified detection pipeline. Returns structured multi-file output."""
    doc = fitz.open(file_path)
    try:
        output = run_document_pipeline(doc, output_format=output_format, include_metadata=include_metadata)
        return output
    finally:
        doc.close()
```

Then modify existing `process_pdf()` to be a thin backward-compat wrapper:

```python
def process_pdf(file_path: str, output_format: str = "markdown") -> str:
    """Process PDF and return body text as string. Backward compatible."""
    output = process_pdf_structured(file_path, output_format=output_format)
    return output.body_text
```

**CRITICAL backward compat strategy:**
1. First, run the existing process_pdf() against all test PDFs and capture output
2. Wire process_pdf() to call process_pdf_structured()
3. Verify output matches (use recall baseline from Plan 02)
4. If output differs, investigate — the body_text from the new pipeline must contain all lines from the old output

**If exact output match is not achievable** (formatting differences due to pipeline reordering), ensure:
- All body text lines are present (recall check)
- No non-body content leaks into body (precision check)
- Formatting is structurally equivalent (headings, paragraphs preserved)

Keep the OLD process_pdf() code as `_process_pdf_legacy()` (renamed, not deleted) so it can be used for A/B comparison during testing. Mark it with `# LEGACY: remove after Phase 11 verification`.

Add imports: `from lib.rag.pipeline.runner import run_document_pipeline` and `from lib.rag.pipeline.models import DocumentOutput`.
  </action>
  <verify>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp
# Verify backward compat: process_pdf still returns a string
uv run python -c "
from lib.rag.orchestrator_pdf import process_pdf, process_pdf_structured
import inspect
sig = inspect.signature(process_pdf)
print(f'process_pdf signature: {sig}')
sig2 = inspect.signature(process_pdf_structured)
print(f'process_pdf_structured signature: {sig2}')
"
# Run existing tests
uv run pytest __tests__/python/ -x --tb=short -q 2>&1 | tail -10
```
  </verify>
  <done>process_pdf_structured() returns DocumentOutput; process_pdf() wraps it for backward compat; legacy code preserved for A/B comparison</done>
</task>

<task type="auto">
  <name>Task 2: Wire multi-file output in orchestrator.py</name>
  <files>lib/rag/orchestrator.py</files>
  <action>
Update `process_document()` in `lib/rag/orchestrator.py` to use `process_pdf_structured()` for PDF files:

1. When processing a PDF, call `process_pdf_structured()` instead of `process_pdf()`
2. Call `output.write_files(base_path)` to save multi-file output
3. Return expanded result dict:
```python
{
    "processed_file_path": str(body_path),
    "footnotes_file_path": str(footnotes_path) if output.footnotes else None,
    "endnotes_file_path": str(endnotes_path) if output.endnotes else None,
    "citations_file_path": str(citations_path) if output.citations else None,
    "metadata_file_path": str(meta_path),
    "content_types_produced": ["body", "footnotes", "metadata"],  # list of what was written
    "stats": { ... }
}
```

4. For non-PDF files (EPUB, TXT), keep existing behavior unchanged (single-file output). Multi-file output is PDF-only for now.

5. Update the MCP tool response in `src/index.ts` (if needed) to include the new file paths. Check if the `process_document_for_rag` tool response currently returns arbitrary dicts — if so, the new fields will flow through automatically. If the response is typed, add the new optional fields.

Ensure the `processed_rag_output/` directory receives the new files with suffix convention.
  </action>
  <verify>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp
# Check orchestrator still works
uv run python -c "
from lib.rag.orchestrator import process_document
import inspect
sig = inspect.signature(process_document)
print(f'process_document signature: {sig}')
print('Orchestrator import OK')
"
# Existing tests
uv run pytest __tests__/python/ -x --tb=short -q 2>&1 | tail -5
```
  </verify>
  <done>orchestrator.py calls process_pdf_structured() for PDFs, writes multi-file output, returns expanded result dict with all file paths</done>
</task>

</tasks>

<verification>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp
# End-to-end: process a test PDF and verify multi-file output
uv run python -c "
from lib.rag.orchestrator_pdf import process_pdf, process_pdf_structured
import glob

# Find a test PDF
pdfs = glob.glob('test_files/*.pdf')
if pdfs:
    pdf = pdfs[0]
    # Backward compat
    old_result = process_pdf(pdf)
    assert isinstance(old_result, str), 'process_pdf must return string'
    print(f'process_pdf({pdf}): {len(old_result)} chars')

    # New structured
    new_result = process_pdf_structured(pdf)
    print(f'process_pdf_structured: body={len(new_result.body_text)} chars')
    if new_result.footnotes:
        print(f'  footnotes: {len(new_result.footnotes)} chars')
    if new_result.document_metadata:
        print(f'  metadata keys: {list(new_result.document_metadata.keys())}')
else:
    print('No test PDFs found')
"
# All tests pass
uv run pytest __tests__/python/ -x --tb=short -q 2>&1 | tail -5
```
</verification>

<success_criteria>
- process_pdf() returns string (backward compat, no test changes needed)
- process_pdf_structured() returns DocumentOutput with body + optional footnotes/endnotes/citations/metadata
- orchestrator.py writes multiple output files for PDFs
- Result dict includes all file paths
- All existing tests pass
- Legacy code preserved for A/B comparison
</success_criteria>

<output>
After completion, create `.planning/phases/11-body-text-purity/11-06-SUMMARY.md`
</output>
