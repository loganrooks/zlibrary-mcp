---
phase: 05-feature-porting-branch-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/index.ts
  - src/lib/zlibrary-api.ts
  - lib/filename_utils.py
  - lib/python_bridge.py
autonomous: true

must_haves:
  truths:
    - "get_book_metadata tool accepts optional `include` parameter for field group selection"
    - "Default metadata response returns core scalar fields (title, author, year, publisher, language, pages, isbn, rating)"
    - "Requesting include=['terms','booklists','ipfs'] adds nested objects to response"
    - "Downloaded filenames include year and language disambiguation when available"
    - "Dead code (_create_enhanced_filename, _sanitize_component) removed from python_bridge.py"
  artifacts:
    - path: "src/index.ts"
      provides: "Updated GetBookMetadataParamsSchema with optional include array"
      contains: "include"
    - path: "src/lib/zlibrary-api.ts"
      provides: "Passes include param to Python and filters response"
    - path: "lib/filename_utils.py"
      provides: "Disambiguation fields (year, language) in unified filename"
      contains: "year"
    - path: "lib/python_bridge.py"
      provides: "No dead code functions"
  key_links:
    - from: "src/index.ts"
      to: "src/lib/zlibrary-api.ts"
      via: "handlers.getBookMetadata passes include param"
    - from: "lib/filename_utils.py"
      to: "lib/python_bridge.py"
      via: "create_unified_filename called with year/language args"
---

<objective>
Enhance existing metadata tool with tiered response (practical default + selectable field groups) and add disambiguation fields (year, language) to download filenames. Clean dead code from python_bridge.py.

Purpose: Fulfills GIT-03 (metadata tool enhancement) and GIT-04 (filename conventions) using existing master implementations.
Output: Enhanced metadata tool schema, filtered responses, improved filenames with disambiguation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-feature-porting-branch-cleanup/05-CONTEXT.md
@.planning/phases/05-feature-porting-branch-cleanup/05-RESEARCH.md
@src/index.ts
@src/lib/zlibrary-api.ts
@lib/filename_utils.py
@lib/python_bridge.py
@lib/enhanced_metadata.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tiered metadata response with `include` parameter</name>
  <files>src/index.ts, src/lib/zlibrary-api.ts</files>
  <action>
1. In `src/index.ts`, update `GetBookMetadataParamsSchema` to add:
   ```
   include: z.array(z.enum(['terms', 'booklists', 'ipfs', 'ratings', 'description'])).optional()
     .describe('Optional field groups to include beyond core defaults. Core always includes: title, author, year, publisher, language, pages, isbn, rating, cover.')
   ```

2. In `src/lib/zlibrary-api.ts`, update the `getBookMetadata` method:
   - Pass the full Python response through
   - After receiving the complete metadata from Python, filter the response:
     - Always include core scalar fields: title, authors, year, publisher, language, pages, isbn, rating, cover, url, categories, extension, filesize
     - Only include `terms` array if 'terms' in include
     - Only include `booklists` array if 'booklists' in include
     - Only include `ipfs_cid` if 'ipfs' in include
     - Only include `interestScore`, `qualityScore` if 'ratings' in include
     - Only include `description` if 'description' in include
   - If `include` is undefined/empty, return only core fields (practical default)

3. Update the tool description in the server.tool() registration to mention the tiered response behavior.

Do NOT modify the Python side — enhanced_metadata.py already returns all fields. Filtering happens in TypeScript.
  </action>
  <verify>
    `npm run build` succeeds. Check that the schema includes the `include` parameter by inspecting the compiled output.
  </verify>
  <done>
    GetBookMetadataParamsSchema has optional `include` array. Response filtering logic exists in zlibrary-api.ts. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add disambiguation fields to filenames + remove dead code</name>
  <files>lib/filename_utils.py, lib/python_bridge.py</files>
  <action>
1. In `lib/filename_utils.py`, update `create_unified_filename()`:
   - Add optional parameters: `year: str = ""`, `language: str = ""`, `publisher: str = ""`
   - Update the filename format to: `{AuthorCamelCase}_{TitleCamelCase}_{Year}_{Lang}_{BookID}.ext`
   - Only include disambiguation segments if non-empty; skip empty ones to avoid double underscores
   - Example: `OrwellGeorge_1984_1949_en_12345.epub` (with year+lang), `OrwellGeorge_1984_12345.epub` (without)
   - Keep backward compatibility: existing calls without year/language still work (empty defaults)

2. In `lib/python_bridge.py`, find where `create_unified_filename` is called during download and pass `year`, `language` from book_details if available. These fields come from the search result or book detail page — use `.get('year', '')` and `.get('language', '')` for safe access.

3. In `lib/python_bridge.py`, delete the dead code functions:
   - `_create_enhanced_filename()`
   - `_sanitize_component()`
   These are unreachable (confirmed in research).

4. Run `uv run pytest` to verify no regressions.
  </action>
  <verify>
    `uv run pytest` passes. Grep for `_create_enhanced_filename` returns no results. Grep for `def create_unified_filename` shows year/language params.
  </verify>
  <done>
    create_unified_filename accepts year/language/publisher params. Download path passes disambiguation fields. Dead code removed. All Python tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` — TypeScript compiles without errors
2. `uv run pytest` — All Python tests pass
3. `node --experimental-vm-modules node_modules/jest/bin/jest.js` — All Jest tests pass
4. Grep confirms no dead code: `grep -r "_create_enhanced_filename\|_sanitize_component" lib/`
5. Schema inspection: `node -e "const s = require('./dist/index.js')" 2>&1` (no import errors)
</verification>

<success_criteria>
- Metadata tool has `include` parameter in schema
- Response without `include` returns only core scalar fields
- Response with `include: ['terms']` adds terms array
- Filenames include year/language when available
- No dead code in python_bridge.py
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-feature-porting-branch-cleanup/05-01-SUMMARY.md`
</output>
