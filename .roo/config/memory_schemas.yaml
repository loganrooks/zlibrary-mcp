active_context:
  default:
    type: object
    properties:
      title: { type: string }
      focus: { type: string }
      actions: { type: [string, array], items: { type: string } } # Allow string or list of strings
      status: { type: string }
      timestamp: { type: string, format: date-time } # Added by script if missing
    required: [title, focus, status]

global_context:
  Product Context:
    type: object
    properties:
      title: { type: string }
      goal: { type: string }
      initial_state: { type: string }
      phase_name: { type: string }
      phase_focus: { type: string }
      timestamp: { type: string, format: date-time }
    required: [title, goal]
  System Patterns:
    type: object
    properties:
      title: { type: string }
      diagram: { type: string } # Mermaid code
      description: { type: string }
      timestamp: { type: string, format: date-time }
    required: [title, diagram]
  Decision Log:
    type: object
    properties:
      title: { type: string }
      context: { type: string }
      decision: { type: string }
      justification: { type: string }
      alternatives: { type: string }
      timestamp: { type: string, format: date-time }
    required: [title, context, decision, justification]
  Progress:
    type: object
    properties:
      title: { type: string }
      status: { type: string }
      deliverables: { type: string }
      notes: { type: string } # Optional notes
      timestamp: { type: string, format: date-time }
    required: [title, status, deliverables]

feedback:
  default:
    type: object
    properties:
      source: { type: string }
      issue: { type: string }
      analysis: { type: string }
      action: { type: string }
      timestamp: { type: string, format: date-time }
    required: [source, issue]

maintenance:
  Maintenance Log:
    type: object
    properties:
      action: { type: string }
      description: { type: string }
      timestamp: { type: string, format: date-time }
    required: [action, description]
  Known Issues:
    type: object
    properties:
      issue_description: { type: string }
      status: { type: string, enum: ["Open", "Investigating", "Resolved"] }
      timestamp: { type: string, format: date-time }
    required: [issue_description, status]
  Structure Changes:
    type: object
    properties:
      change_description: { type: string }
      timestamp: { type: string, format: date-time }
    required: [change_description]
  Future Improvements:
    type: object
    properties:
      improvement_idea: { type: string }
      timestamp: { type: string, format: date-time }
    required: [improvement_idea]

# --- Mode-Specific Schemas ---
sparc:
  Delegations Log:
    type: object
    properties:
      task_name: { type: string }
      mode_slug: { type: string }
      description: { type: string }
      deliverable: { type: string }
      status: { type: string, enum: ["pending", "active", "completed", "blocked", "failed"] }
      completion_time: { type: string, format: date-time }
      outcome: { type: string }
      progress_link: { type: string }
      timestamp: { type: string, format: date-time }
    required: [task_name, mode_slug, description, deliverable, status]
  Workflow State:
    type: object
    properties:
      phase: { type: string }
      phase_start: { type: string, format: date-time }
      focus: { type: string }
      actions: { type: [string, array], items: { type: string } }
      timestamp: { type: string, format: date-time }
    required: [phase, focus, actions]

tdd:
  Test Plans:
    type: object
    properties:
      title: { type: string }
      unit_tests:
        type: array
        items:
          type: object
          properties:
            description: { type: string }
            expected: { type: string }
            status: { type: string, enum: ["Planned", "Written", "Passing", "Failing"] }
          required: [description, expected, status]
      integration_tests:
        type: array
        items:
          type: object
          properties:
            description: { type: string }
            expected: { type: string }
            status: { type: string, enum: ["Planned", "Written", "Passing", "Failing"] }
          required: [description, expected, status]
      edge_cases:
        type: array
        items:
          type: object
          properties:
            description: { type: string }
            test_approach: { type: string }
          required: [description]
      timestamp: { type: string, format: date-time }
    required: [title]
  Test Coverage Summary:
    type: object
    properties:
      line: { type: number }
      branch: { type: number }
      function: { type: number }
      components: { type: string } # Or object if more structured
      attention_areas: { type: string }
      timestamp: { type: string, format: date-time }
    required: [line, branch, function]
  Test Fixtures:
    type: object
    properties:
      fixture_name: { type: string }
      purpose: { type: string }
      location: { type: string }
      usage: { type: string }
      timestamp: { type: string, format: date-time }
    required: [fixture_name, purpose, location]
  TDD Cycles Log:
    type: object
    properties:
      feature_component: { type: string }
      start_time: { type: string, format: date-time }
      end_time: { type: string, format: date-time }
      red_description: { type: string }
      green_description: { type: string }
      refactor_description: { type: string }
      outcomes: { type: string }
      timestamp: { type: string, format: date-time }
    required: [feature_component, red_description, green_description, refactor_description]
  Test Execution Results:
    type: object
    properties:
      trigger: { type: string }
      env: { type: string }
      suite: { type: string }
      result: { type: string, enum: ["PASS", "FAIL", "SKIP"] }
      summary: { type: string }
      report_link: { type: string }
      failures: { type: string }
      timestamp: { type: string, format: date-time }
    required: [trigger, env, suite, result, summary]

code:
  Implementation Notes:
    type: object
    properties:
      feature_component: { type: string }
      approach: { type: string }
      files: { type: [string, array], items: { type: string } }
      notes: { type: string }
      timestamp: { type: string, format: date-time }
    required: [feature_component, approach, files]
  Technical Debt Log:
    type: object
    properties:
      issue_name_id: { type: string }
      status: { type: string, enum: ["Open", "Investigating", "Resolved", "Deferred"] }
      identified_time: { type: string, format: date-time }
      location: { type: string }
      description: { type: string }
      impact: { type: string }
      priority: { type: string, enum: ["High", "Medium", "Low"] }
      solution: { type: string }
      resolution: { type: string }
      resolved_date: { type: string, format: date-time }
      timestamp: { type: string, format: date-time }
    required: [issue_name_id, status, location, description, priority]
  Dependencies Log:
    type: object
    properties:
      dependency_name: { type: string }
      version: { type: string }
      purpose: { type: string }
      components: { type: [string, array], items: { type: string } }
      config_notes: { type: string }
      timestamp: { type: string, format: date-time }
    required: [dependency_name, version, purpose]
  Code Patterns Log:
    type: object
    properties:
      pattern_name: { type: string }
      description: { type: string }
      example_usage: { type: string }
      rationale: { type: string }
      timestamp: { type: string, format: date-time }
    required: [pattern_name, description, rationale]

spec-pseudocode:
  Functional Requirements:
    type: object
    properties:
      feature_name: { type: string }
      description: { type: string }
      acceptance_criteria: { type: [string, array], items: { type: string } }
      dependencies: { type: string }
      status: { type: string, enum: ["Draft", "Approved", "Implemented"] }
      timestamp: { type: string, format: date-time }
    required: [feature_name, description, acceptance_criteria, status]
  System Constraints:
    type: object
    properties:
      constraint_name: { type: string }
      description: { type: string }
      impact: { type: string }
      mitigation_strategy: { type: string }
      timestamp: { type: string, format: date-time }
    required: [constraint_name, description, impact]
  Edge Cases:
    type: object
    properties:
      feature_component: { type: string }
      scenario: { type: string }
      expected_behavior: { type: string }
      testing_approach: { type: string }
      timestamp: { type: string, format: date-time }
    required: [feature_component, scenario, expected_behavior]
  Pseudocode Library:
    type: object
    properties:
      component_feature: { type: string }
      function_name: { type: string }
      pseudocode: { type: string }
      tdd_anchors:
        type: array
        items:
          type: object
          properties:
            description: { type: string }
          required: [description]
      timestamp: { type: string, format: date-time }
    required: [component_feature, function_name, pseudocode, tdd_anchors]

architect:
  System Diagrams:
    type: object
    properties:
      diagram_name: { type: string }
      description: { type: string }
      diagram_code: { type: string } # Mermaid code
      notes: { type: string }
      timestamp: { type: string, format: date-time }
    required: [diagram_name, description, diagram_code]
  Component Specifications:
    type: object
    properties:
      component_name: { type: string }
      responsibility: { type: string }
      dependencies: { type: [string, array], items: { type: string } }
      interfaces_exposed: { type: [string, array], items: { type: string } }
      internal_structure: { type: string }
      timestamp: { type: string, format: date-time }
    required: [component_name, responsibility]
  Interface Definitions:
    type: object
    properties:
      interface_name: { type: string }
      purpose: { type: string }
      method_endpoint_name: { type: string }
      input: { type: string }
      output: { type: string }
      behavior: { type: string }
      security_notes: { type: string }
      timestamp: { type: string, format: date-time }
    required: [interface_name, purpose, method_endpoint_name, input, output, behavior]
  Data Models:
    type: object
    properties:
      model_name: { type: string }
      purpose: { type: string }
      structure: { type: string } # JSON or similar
      relationships: { type: string }
      timestamp: { type: string, format: date-time }
    required: [model_name, purpose, structure]

security-review:
  Security Findings Log:
    type: object
    properties:
      finding_id: { type: string }
      short_description: { type: string }
      status: { type: string, enum: ["Open", "Resolved", "Risk Accepted"] }
      severity: { type: string, enum: ["Critical", "High", "Medium", "Low", "Info"] }
      components: { type: [string, array], items: { type: string } }
      description: { type: string }
      owasp: { type: string }
      poc: { type: string }
      remediation: { type: string }
      resolved_time: { type: string, format: date-time }
      timestamp: { type: string, format: date-time }
    required: [finding_id, short_description, status, severity, components, description, remediation]
  Threat Models:
    type: object
    properties:
      component_feature: { type: string }
      diagram_link_desc: { type: string }
      boundaries: { type: string }
      actors: { type: [string, array], items: { type: string } }
      threats_list: { type: array, items: { type: object } } # Define threat object structure if needed
      timestamp: { type: string, format: date-time }
    required: [component_feature, boundaries, actors, threats_list]
  Project Vulnerability Patterns:
    type: object
    properties:
      pattern_name: { type: string }
      description: { type: string }
      examples: { type: [string, array], items: { type: string } } # Finding IDs
      locations: { type: string }
      secure_practice: { type: string }
      last_seen: { type: string, format: date-time }
      timestamp: { type: string, format: date-time }
    required: [pattern_name, description, secure_practice]
  Security Tool Usage:
    type: object
    properties:
      tool_name: { type: string }
      target: { type: string }
      config: { type: string }
      results: { type: string }
      notes: { type: string }
      timestamp: { type: string, format: date-time }
    required: [tool_name, target, results]
  Compliance Checks:
    type: object
    properties:
      requirement_id: { type: string }
      controls: { type: string }
      status: { type: string, enum: ["Compliant", "Non-Compliant", "Partial", "NA"] }
      evidence: { type: string }
      notes: { type: string }
      timestamp: { type: string, format: date-time }
    required: [requirement_id, controls, status]

docs-writer:
  Documentation Plan:
    type: object
    properties:
      doc_section_name: { type: string }
      type: { type: string, enum: ["Guide", "API", "Tutorial", "README"] }
      audience: { type: string }
      outline: { type: [string, array], items: { type: string } }
      status: { type: string, enum: ["Planned", "Draft", "Review", "Done"] }
      owner: { type: string }
      source: { type: string }
      location: { type: string }
      timestamp: { type: string, format: date-time }
    required: [doc_section_name, type, audience, status, location]
  Project Glossary & Terminology:
    type: object
    properties:
      term_name: { type: string }
      definition: { type: string }
      usage: { type: string }
      naming_conventions: { type: array, items: { type: object } } # Define convention object if needed
      timestamp: { type: string, format: date-time }
    required: [term_name, definition]
  Documentation Debt Log:
    type: object
    properties:
      missing_outdated_topic: { type: string }
      status: { type: string, enum: ["Open", "Resolved"] }
      location: { type: string }
      description: { type: string }
      priority: { type: string, enum: ["High", "Medium", "Low"] }
      resolution: { type: string }
      resolved_date: { type: string, format: date-time }
      timestamp: { type: string, format: date-time }
    required: [missing_outdated_topic, status, location, description, priority]
  Documentation User Feedback:
    type: object
    properties:
      source: { type: string }
      document: { type: string }
      feedback: { type: string }
      analysis: { type: string }
      action: { type: string }
      timestamp: { type: string, format: date-time }
    required: [source, document, feedback]
  Documentation Style Guide:
    type: object
    properties:
      formatting_markdown: { type: string }
      formatting_code_blocks: { type: string }
      tone: { type: string }
      templates: { type: string }
      timestamp: { type: string, format: date-time }
    required: [formatting_markdown, tone]

integration:
  Integration Points Catalog:
    type: object
    properties:
      point_name: { type: string }
      components: { type: [string, array], items: { type: string } }
      type: { type: string, enum: ["API", "Event", "Data", "UI"] }
      contract: { type: string }
      data_flow: { type: string }
      protocol: { type: string }
      deps: { type: [string, array], items: { type: string } }
      status: { type: string, enum: ["Planned", "Done", "Tested", "Live", "Deprecated"] }
      issues: { type: string }
      timestamp: { type: string, format: date-time }
    required: [point_name, components, type, contract, status]
  System Dependency Map:
    type: object
    properties:
      update_description: { type: string } # e.g., "Added Service C dependency"
      diagram: { type: string } # Optional Mermaid diagram
      dependencies: { type: object } # e.g., {"Service A": ["Service B", "Database X"]}
      timestamp: { type: string, format: date-time }
    required: [update_description]
  Integration Test Scenarios:
    type: object
    properties:
      scenario_name: { type: string }
      components: { type: [string, array], items: { type: string } }
      steps: { type: [string, array], items: { type: string } }
      expected: { type: string }
      status: { type: string, enum: ["Manual", "Automated", "Planned"] }
      last_run_timestamp: { type: string, format: date-time }
      last_run_result: { type: string, enum: ["PASS", "FAIL", "SKIP", "Not Run"] }
      timestamp: { type: string, format: date-time }
    required: [scenario_name, components, steps, expected, status]
  Integration Issues Log:
    type: object
    properties:
      issue_id: { type: string }
      short_desc: { type: string }
      status: { type: string, enum: ["Open", "Investigating", "Resolved", "Blocked"] }
      identified_timestamp: { type: string, format: date-time }
      components: { type: [string, array], items: { type: string } }
      symptoms: { type: string }
      root_cause: { type: string }
      resolution: { type: string }
      resolved_date: { type: string, format: date-time }
      timestamp: { type: string, format: date-time }
    required: [issue_id, short_desc, status, identified_timestamp, components, symptoms]
  Integration Release Notes:
    type: object
    properties:
      version: { type: string }
      new_integrations: { type: array, items: { type: string } }
      changes: { type: array, items: { type: string } }
      fixes: { type: array, items: { type: string } } # Issue IDs
      known_issues: { type: array, items: { type: string } } # Issue IDs
      timestamp: { type: string, format: date-time }
    required: [version]

monitor: 
  Metrics Catalog:
    type: object
    properties:
      metric_name: { type: string }
      type: { type: string, enum: ["Counter", "Gauge", "Histogram", "Summary"] }
      desc: { type: string }
      source: { type: string }
      labels: { type: [string, array], items: { type: string } }
      query: { type: string }
      range: { type: string }
      alerts: { type: [string, array], items: { type: string } } 
      timestamp: { type: string, format: date-time }
    required: [metric_name, type, desc, source]
  Alerting Rules:
    type: object
    properties:
      alert_name: { type: string }
      metric_expr: { type: string }
      threshold: { type: string }
      duration: { type: string }
      severity: { type: string, enum: ["Critical", "Warning", "Info"] }
      desc: { type: string }
      notify: { type: string }
      runbook: { type: string }
      timestamp: { type: string, format: date-time }
    required: [alert_name, metric_expr, threshold, duration, severity, desc, notify]
  Production Incident History:
    type: object
    properties:
      incident_id: { type: string }
      short_desc: { type: string }
      detected: { type: string, format: date-time }
      resolved: { type: string, format: date-time }
      duration: { type: string }
      severity: { type: string }
      affected: { type: [string, array], items: { type: string } }
      impact: { type: string }
      symptoms: { type: string }
      root_cause: { type: string }
      resolution: { type: string }
      timeline: { type: string } # Could be array of events
      lessons: { type: string }
      related: { type: [string, array], items: { type: string } }
      timestamp: { type: string, format: date-time }
    required: [incident_id, short_desc, detected, severity, affected, impact, resolution]
  Service Level Objectives (SLOs):
    type: object
    properties:
      slo_name: { type: string }
      desc: { type: string }
      metric_sli: { type: string } # Link to Metrics Catalog entry
      target: { type: number } # e.g., 99.9
      window: { type: string } # e.g., "30d"
      status: { type: number } # Current attainment %
      status_category: { type: string, enum: ["Tracking", "At Risk", "Breached"] }
      budget: { type: number } # Remaining error budget %
      timestamp: { type: string, format: date-time }
    required: [slo_name, desc, metric_sli, target, window]
  Performance Benchmarks:
    type: object
    properties:
      benchmark_name: { type: string }
      metric: { type: string }
      baseline_value: { type: number }
      baseline_date: { type: string, format: date-time }
      context: { type: string }
      current_value: { type: number }
      current_date: { type: string, format: date-time }
      trend: { type: string, enum: ["Improving", "Degrading", "Stable"] }
      timestamp: { type: string, format: date-time }
    required: [benchmark_name, metric, baseline_value, baseline_date]

optimizer: # Renamed from refinement-optimization-mode
  Optimization History Log:
    type: object
    properties:
      short_description: { type: string }
      target: { type: string }
      type: { type: string, enum: ["Performance", "Modularity", "Readability", "Config"] }
      desc: { type: string }
      metrics_before: { type: string }
      metrics_after: { type: string }
      related_debt: { type: string } # Link to Tech Debt Item ID
      related_issue: { type: string } # Link to external issue tracker
      timestamp: { type: string, format: date-time }
    required: [short_description, target, type, desc]
  Technical Debt (Optimization Focus):
    type: object
    properties:
      ref_id: { type: string }
      status: { type: string, enum: ["Targeted", "Resolved", "Deferred"] }
      location: { type: string }
      desc: { type: string }
      approach: { type: string }
      resolution_date: { type: string, format: date-time }
      link: { type: string } # Link to Optimization History entry
      timestamp: { type: string, format: date-time }
    required: [ref_id, status, location, desc]
  Performance Analysis Reports:
    type: object
    properties:
      tool_used: { type: string }
      target: { type: string }
      trigger: { type: string }
      findings: { type: [string, array], items: { type: string } }
      summary: { type: string }
      link: { type: string }
      insights: { type: string }
      timestamp: { type: string, format: date-time }
    required: [tool_used, target, trigger, summary]

ask:
  Guidance Patterns Log:
    type: object
    properties:
      pattern_name: { type: string }
      problem_context: { type: string }
      guidance_approach: { type: string }
      outcome: { type: string }
      effectiveness_notes: { type: string }
      timestamp: { type: string, format: date-time }
    required: [pattern_name, problem_context, guidance_approach, outcome]
  Task Formulation Examples:
    type: object
    properties:
      target_mode: { type: string }
      user_need: { type: string }
      formulated_task: { type: string } # XML string
      key_context_provided: { type: [string, array], items: { type: string } }
      timestamp: { type: string, format: date-time }
    required: [target_mode, user_need, formulated_task]
  Mode Coordination Observations:
    type: object
    properties:
      mode_a: { type: string }
      mode_b: { type: string }
      task_context: { type: string }
      observation: { type: string }
      recommendation: { type: string }
      timestamp: { type: string, format: date-time }
    required: [mode_a, mode_b, task_context, observation]

devops:
  Deployment History Log:
    type: object
    properties:
      env: { type: string }
      comps: { type: [string, array], items: { type: string } }
      version: { type: string }
      trigger: { type: string }
      status: { type: string, enum: ["Success", "Fail", "Rollback", "InProgress"] }
      duration: { type: string }
      rollback_version: { type: string }
      notes: { type: string }
      timestamp: { type: string, format: date-time }
    required: [env, comps, version, trigger, status]
  Infrastructure Configuration Overview:
    type: object
    properties:
      env: { type: string }
      component: { type: string }
      provider: { type: string }
      region: { type: string }
      version: { type: string }
      config: { type: string }
      managed_by: { type: string, enum: ["IaC", "Manual", "Mixed"] }
      iac_link: { type: string }
      timestamp: { type: string, format: date-time }
    required: [env, component, provider, managed_by]
  Environment Registry:
    type: object
    properties:
      name: { type: string }
      purpose: { type: string }
      url: { type: string }
      access: { type: string }
      services: { type: [string, array], items: { type: string } }
      data: { type: string }
      status: { type: string, enum: ["Active", "Maintenance", "Building", "Inactive"] }
      owner: { type: string }
      timestamp: { type: string, format: date-time }
    required: [name, purpose, status, owner]
  CI/CD Pipeline Documentation:
    type: object
    properties:
      pipeline_name: { type: string }
      tool: { type: string }
      trigger: { type: string }
      repo: { type: string }
      workflow_path: { type: string }
      stages: { type: [string, array], items: { type: string } }
      vars: { type: string }
      timestamp: { type: string, format: date-time }
    required: [pipeline_name, tool, trigger, repo, workflow_path, stages]
  Secrets Management Strategy:
    type: object
    properties:
      tool: { type: string }
      access_control: { type: string }
      rotation_policy: { type: string }
      injection_method: { type: string }
      auditing: { type: string }
      timestamp: { type: string, format: date-time }
    required: [tool, access_control, injection_method, auditing]

debug:
  Issue History:
    type: object
    properties:
      issue_id: { type: string }
      short_description: { type: string }
      status: { type: string, enum: ["Open", "Investigating", "Resolved", "Blocked"] }
      reported: { type: string, format: date-time }
      severity: { type: string }
      symptoms: { type: string }
      investigation: { type: array, items: { type: string } } # Array of steps/timestamps
      root_cause: { type: string }
      fix_applied: { type: string }
      verification: { type: string }
      related_issues: { type: [string, array], items: { type: string } }
      timestamp: { type: string, format: date-time }
    required: [issue_id, short_description, status, reported, severity, symptoms]
  Recurring Bug Patterns:
    type: object
    properties:
      pattern_name: { type: string }
      identification: { type: string }
      causes: { type: [string, array], items: { type: string } }
      components: { type: [string, array], items: { type: string } }
      resolution: { type: string }
      related: { type: [string, array], items: { type: string } } # Issue IDs
      last_seen: { type: string, format: date-time }
      timestamp: { type: string, format: date-time }
    required: [pattern_name, identification, causes, resolution]
  Environment-Specific Notes:
    type: object
    properties:
      env_name: { type: string }
      issue_behavior: { type: string }
      config: { type: string }
      workaround: { type: string }
      timestamp: { type: string, format: date-time }
    required: [env_name, issue_behavior]
  Performance Observations:
    type: object
    properties:
      issue_id: { type: string } # Link to Issue History
      observation: { type: string }
      metric: { type: string }
      context: { type: string }
      cause: { type: string }
      timestamp: { type: string, format: date-time }
    required: [issue_id, observation]
  Debugging Tools & Techniques:
    type: object
    properties:
      tool_technique_name: { type: string }
      context: { type: string }
      usage: { type: string }
      effectiveness: { type: string }
      timestamp: { type: string, format: date-time }
    required: [tool_technique_name, context, usage]

# --- System Self-Modification Modes ---
system-modifier: # Renamed from plan-implementer
  System Modification Log:
    type: object
    properties:
      plan_reference: { type: string } # ID or name of the plan
      step_description: { type: string }
      target_file: { type: string } # Specifically log the target file
      status: { type: string, enum: ["Started", "Verified", "Completed", "Skipped", "Error", "Halted"] }
      details: { type: string } # Optional details or tool output summary
      timestamp: { type: string, format: date-time }
    required: [plan_reference, step_description, target_file, status]
  Execution Issues Log:
    type: object
    properties:
      plan_reference: { type: string }
      step_description: { type: string }
      target_file: { type: string }
      issue_type: { type: string, enum: ["Mismatch", "Tool Error", "Script Error"] }
      error_message: { type: string }
      resolution_status: { type: string, enum: ["Reported", "Awaiting Instructions"] }
      timestamp: { type: string, format: date-time }
    required: [plan_reference, step_description, target_file, issue_type, error_message, resolution_status]

system-strategist:
  Improvement Analysis Log:
    type: object
    properties:
      analysis_summary: { type: string }
      data_sources: { type: array, items: { type: string } } # e.g., ["feedback/code.md", "user_request"]
      identified_issues: { type: array, items: { type: string } }
      metrics_impacted: { type: array, items: { type: string, enum: ["Autonomy", "Cost", "Quality", "Robustness"] } }
      timestamp: { type: string, format: date-time }
    required: [analysis_summary, data_sources, identified_issues, metrics_impacted]
  External Knowledge Log (MCP):
    type: object
    properties:
      query_purpose: { type: string } # Why the query was made
      server_id: { type: string }
      query_text: { type: string }
      response_summary: { type: string } # Summary of findings from MCP
      key_insight: { type: string } # How the findings inform strategy/planning
      source_references: { type: array, items: { type: string } } # e.g., ArXiv IDs, URLs
      timestamp: { type: string, format: date-time }
    required: [query_purpose, server_id, query_text, response_summary, key_insight]
  Strategic Goals:
    type: object
    properties:
      goal_description: { type: string }
      measurable_outcome: { type: string } # How success will be measured
      related_analysis: { type: string } # Link to analysis log entry timestamp/ID
      priority: { type: string, enum: ["High", "Medium", "Low"] }
      timestamp: { type: string, format: date-time }
    required: [goal_description, measurable_outcome, related_analysis, priority]
  Generated Plans Log:
    type: object
    properties:
      plan_summary: { type: string }
      related_goal: { type: string } # Link to strategic goal entry timestamp/ID
      target_files: { type: array, items: { type: string } } # Key .roo files targeted
      status: { type: string, enum: ["Generated", "SentToModifier", "Completed", "Failed"] }
      modifier_outcome: { type: string } # Optional: Summary from system-modifier
      timestamp: { type: string, format: date-time }
    required: [plan_summary, related_goal, target_files, status]