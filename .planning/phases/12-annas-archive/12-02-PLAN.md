---
phase: 12-annas-archive
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - lib/python_bridge.py
  - src/lib/source-router.ts
  - src/lib/zlibrary-api.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "python_bridge.py dispatches search/download to correct adapter based on source parameter"
    - "source-router.ts resolves which source(s) to query based on source param and env config"
    - "Fallback activates when primary source errors/timeouts and BOOK_SOURCE_FALLBACK_ENABLED=true"
    - "On fallback, clean switch — no partial result mixing from failed source"
    - "search_books MCP tool accepts optional source parameter ('zlibrary' | 'libgen' | 'auto')"
    - "All search results include source field indicating which source returned them"
    - "BOOK_SOURCE_DEFAULT env var controls default source (default 'auto')"
    - "Existing search_books behavior unchanged when source param not provided"
  artifacts:
    - path: "src/lib/source-router.ts"
      provides: "resolveSource(), searchWithFallback(), SourceRouterConfig"
      contains: "searchWithFallback"
    - path: "lib/python_bridge.py"
      provides: "Updated search/download dispatch with source routing"
      contains: "source_adapter"
    - path: "src/index.ts"
      provides: "source parameter on search tool schemas"
      contains: "source.*zlibrary.*libgen.*auto"
  key_links:
    - from: "src/lib/source-router.ts"
      to: "src/lib/zlibrary-api.ts"
      via: "calls searchBooks with source param"
      pattern: "searchBooks|callPythonFunction"
    - from: "lib/python_bridge.py"
      to: "lib/zlib_adapter.py"
      via: "imports and uses ZLibAdapter for zlibrary source"
      pattern: "from.*zlib_adapter.*import"
    - from: "lib/python_bridge.py"
      to: "lib/libgen_adapter.py"
      via: "imports and uses LibgenAdapter for libgen source"
      pattern: "from.*libgen_adapter.*import"
---

<objective>
Wire source routing through the full stack: Python bridge dispatch, TypeScript source router with fallback, and MCP tool schema updates.

Purpose: Enables the `source` parameter on search tools, fallback when primary source fails, and source attribution in results. This is the core integration that makes multi-source work end-to-end.
Output: `src/lib/source-router.ts` (new), updated `lib/python_bridge.py`, `src/lib/zlibrary-api.ts`, `src/index.ts`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-annas-archive/12-RESEARCH.md
@.planning/phases/12-annas-archive/12-01-SUMMARY.md
@src/index.ts
@src/lib/zlibrary-api.ts
@lib/python_bridge.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add source routing to Python bridge</name>
  <files>lib/python_bridge.py</files>
  <action>
1. Add imports at top of python_bridge.py:
   ```python
   from lib.source_adapter import UnifiedBookResult
   from lib.zlib_adapter import ZLibAdapter
   from lib.libgen_adapter import LibgenAdapter
   ```

2. Add module-level adapter instances (lazy-initialized):
   ```python
   _zlib_adapter: ZLibAdapter = None
   _libgen_adapter: LibgenAdapter = None

   async def get_adapter(source: str):
       """Get adapter for the given source."""
       global _zlib_adapter, _libgen_adapter
       if source == 'zlibrary':
           if _zlib_adapter is None:
               _zlib_adapter = ZLibAdapter()
           return _zlib_adapter
       elif source == 'libgen':
           if _libgen_adapter is None:
               _libgen_adapter = LibgenAdapter()
           return _libgen_adapter
       raise ValueError(f"Unknown source: {source}")
   ```

3. Add `search_with_source()` function:
   ```python
   async def search_with_source(query, source='auto', **kwargs):
       """Search using specified source or auto-detect."""
       default_source = os.environ.get('BOOK_SOURCE_DEFAULT', 'auto')
       fallback_enabled = os.environ.get('BOOK_SOURCE_FALLBACK_ENABLED', 'true').lower() == 'true'

       if source == 'auto':
           source = default_source if default_source != 'auto' else 'zlibrary'

       adapter = await get_adapter(source)
       try:
           results = await adapter.search(query, **kwargs)
           return {'results': [r.to_dict() for r in results], 'source': source}
       except Exception as e:
           if fallback_enabled:
               fallback = 'libgen' if source == 'zlibrary' else 'zlibrary'
               logger.warning(f"Primary source {source} failed: {e}. Falling back to {fallback}")
               fallback_adapter = await get_adapter(fallback)
               results = await fallback_adapter.search(query, **kwargs)
               return {'results': [r.to_dict() for r in results], 'source': fallback, 'fallback': True}
           raise
   ```

4. Update the `main()` dispatch to handle a new `search_with_source` function name. Add it alongside existing `search` handler in the main dispatch loop. When `function` is `search_with_source`, call the new function.

5. Keep existing `search()` function unchanged for backward compatibility. The new `search_with_source()` is additive.
  </action>
  <verify>
    ```bash
    cd /home/rookslog/workspace/projects/zlibrary-mcp
    uv run python -c "from lib.python_bridge import search_with_source; print('OK')"
    # Existing tests pass
    uv run pytest --tb=short -q
    ```
  </verify>
  <done>python_bridge.py has search_with_source() that dispatches to adapters with fallback logic</done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript source router and update MCP tools</name>
  <files>src/lib/source-router.ts, src/lib/zlibrary-api.ts, src/index.ts</files>
  <action>
1. Create `src/lib/source-router.ts`:
   - Export `SourceType = 'zlibrary' | 'libgen' | 'auto'`
   - Export `SourceRouterConfig` interface with: defaultSource, fallbackEnabled, parallelMode (all from env vars)
   - Export `getSourceConfig()` that reads env vars: BOOK_SOURCE_DEFAULT (default 'auto'), BOOK_SOURCE_FALLBACK_ENABLED (default 'true'), BOOK_SOURCE_PARALLEL (default 'false')
   - Export `resolveSource(requested: SourceType, config: SourceRouterConfig): SourceType[]` — if not 'auto' return [requested]; if parallel return ['zlibrary', 'libgen']; else return [config.defaultSource === 'auto' ? 'zlibrary' : config.defaultSource]

2. Update `src/lib/zlibrary-api.ts`:
   - Add `searchWithSource()` export that calls `callPythonFunction('search_with_source', { query, source, ...params })`. This delegates source routing and fallback to Python.
   - Keep existing `searchBooks()` unchanged for backward compatibility.

3. Update `src/index.ts`:
   - Add `source` parameter to `SearchBooksParamsSchema`: `source: z.enum(['zlibrary', 'libgen', 'auto']).optional().default('auto').describe('Book source...')`
   - In the search_books tool handler, when `source` is provided and not 'auto', call the new `searchWithSource()`. When 'auto', use `getSourceConfig()` to determine behavior.
   - Add source field to tool description: "Search for books. Use source parameter to specify search source."
   - Also add `source` to `SearchByTermParamsSchema`, `SearchByAuthorParamsSchema`, and `SearchAdvancedParamsSchema` — these are search tools that should support source selection.
   - Ensure all search result objects include the `source` field in the response.

4. Build and verify:
   ```bash
   npm run build
   ```
  </action>
  <verify>
    ```bash
    cd /home/rookslog/workspace/projects/zlibrary-mcp
    npm run build
    # Verify source param in compiled output
    grep -l "source.*zlibrary.*libgen" dist/index.js
    grep -l "searchWithSource" dist/lib/zlibrary-api.js
    # Existing Jest tests pass
    node --experimental-vm-modules node_modules/jest/bin/jest.js --passWithNoTests
    ```
  </verify>
  <done>source-router.ts created, search tools accept source param, TypeScript builds clean, existing tests pass</done>
</task>

</tasks>

<verification>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp

# Build succeeds
npm run build

# Python tests pass
uv run pytest --tb=short -q

# Jest tests pass
node --experimental-vm-modules node_modules/jest/bin/jest.js --passWithNoTests

# Source param exists in compiled tool schemas
grep "source" dist/index.js | grep -i "zlibrary\|libgen\|auto" | head -3

# New files exist
test -f src/lib/source-router.ts && echo "source-router.ts exists"
test -f dist/lib/source-router.js && echo "source-router.js compiled"
```
</verification>

<success_criteria>
- Python bridge dispatches to correct adapter based on source parameter
- Fallback triggers on primary source failure when enabled
- Clean switch on fallback (no partial result mixing)
- source-router.ts provides config from env vars
- search_books MCP tool accepts source parameter
- All search results include source field
- Build succeeds, existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-annas-archive/12-02-SUMMARY.md`
</output>
