---
phase: 12-annas-archive
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - lib/python_bridge.py
  - src/lib/source-router.ts
  - __tests__/python/test_source_adapters.py
  - __tests__/python/test_source_routing.py
autonomous: true

must_haves:
  truths:
    - "Parallel mode queries both sources and merges results when BOOK_SOURCE_PARALLEL=true"
    - "Parallel mode deduplicates by MD5 hash, preferring Z-Library results"
    - "Source routing unit tests cover: auto mode, explicit source, fallback trigger, parallel merge"
    - "Adapter unit tests cover: LibGen search normalization, ZLib search normalization, health_check"
    - "Environment variable configuration tested: BOOK_SOURCE_DEFAULT, BOOK_SOURCE_FALLBACK_ENABLED, BOOK_SOURCE_PARALLEL, LIBGEN_MIRROR"
  artifacts:
    - path: "__tests__/python/test_source_adapters.py"
      provides: "Unit tests for ZLibAdapter and LibgenAdapter"
      contains: "test_libgen_search"
    - path: "__tests__/python/test_source_routing.py"
      provides: "Unit tests for search_with_source dispatch and parallel mode"
      contains: "test_parallel_mode"
  key_links:
    - from: "lib/python_bridge.py"
      to: "lib/libgen_adapter.py"
      via: "parallel mode calls both adapters concurrently"
      pattern: "asyncio.gather"
---

<objective>
Implement parallel search mode and comprehensive tests for the multi-source system.

Purpose: Completes the multi-source feature set with parallel querying and validates the entire source routing pipeline with unit tests. Parallel mode was explicitly requested by the user.
Output: Updated `lib/python_bridge.py` (parallel mode), `src/lib/source-router.ts` (parallel routing), test files
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-annas-archive/12-RESEARCH.md
@.planning/phases/12-annas-archive/12-02-SUMMARY.md
@lib/python_bridge.py
@src/lib/source-router.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement parallel search mode</name>
  <files>lib/python_bridge.py, src/lib/source-router.ts</files>
  <action>
1. Update `search_with_source()` in python_bridge.py to handle parallel mode:
   - Read `BOOK_SOURCE_PARALLEL` env var (default 'false')
   - When parallel=true and source='auto': run both adapters concurrently via `asyncio.gather()` with `return_exceptions=True`
   - Merge results: deduplicate by MD5 hash. If same MD5 from both sources, prefer Z-Library result. If no MD5 match, include both.
   - Results from both sources returned with their respective `source` field
   - If one source fails in parallel mode, return results from the other (graceful degradation)
   - Add `parallel` field to response when parallel mode was used

2. Add dedup helper:
   ```python
   def _deduplicate_results(zlib_results, libgen_results):
       """Merge results, dedup by MD5, prefer Z-Library."""
       seen_md5 = {}
       merged = []
       for r in zlib_results:
           if r.md5:
               seen_md5[r.md5] = True
           merged.append(r)
       for r in libgen_results:
           if r.md5 and r.md5 in seen_md5:
               continue  # Skip duplicate
           merged.append(r)
       return merged
   ```

3. Update `src/lib/source-router.ts` `resolveSource()`:
   - When parallel mode and source='auto', return ['zlibrary', 'libgen'] (this signals the Python side to use parallel)
   - Pass `parallel: true` through to Python when config.parallelMode is true
  </action>
  <verify>
    ```bash
    cd /home/rookslog/workspace/projects/zlibrary-mcp
    npm run build
    uv run python -c "from lib.python_bridge import search_with_source; print('OK')"
    ```
  </verify>
  <done>Parallel mode queries both sources, deduplicates by MD5, handles partial failures gracefully</done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for source adapters and routing</name>
  <files>__tests__/python/test_source_adapters.py, __tests__/python/test_source_routing.py</files>
  <action>
1. Create `__tests__/python/test_source_adapters.py`:
   - Use pytest + pytest-mock
   - Test `LibgenAdapter._normalize()` with sample libgen result dict → verify UnifiedBookResult fields
   - Test `LibgenAdapter.search()` mocking `asyncio.to_thread` and `LibgenSearch` → verify results normalized
   - Test `LibgenAdapter.health_check()` success and failure cases
   - Test `ZLibAdapter.search()` mocking EAPI client → verify results normalized with source='zlibrary'
   - Test `ZLibAdapter.health_check()` mocking eapi_health_check → True/False

2. Create `__tests__/python/test_source_routing.py`:
   - Test `search_with_source(query, source='zlibrary')` routes to ZLibAdapter (mock adapter)
   - Test `search_with_source(query, source='libgen')` routes to LibgenAdapter (mock adapter)
   - Test `search_with_source(query, source='auto')` uses default source from env
   - Test fallback: mock primary adapter to raise, verify fallback adapter called
   - Test fallback disabled: mock primary to raise, verify exception propagated when BOOK_SOURCE_FALLBACK_ENABLED=false
   - Test parallel mode: mock both adapters, verify both called via asyncio.gather, results merged
   - Test parallel dedup: both return book with same MD5 → only one in output, Z-Library preferred
   - Test parallel partial failure: one adapter fails → results from other returned
   - Use `monkeypatch.setenv()` for env var tests
  </action>
  <verify>
    ```bash
    cd /home/rookslog/workspace/projects/zlibrary-mcp
    uv run pytest __tests__/python/test_source_adapters.py __tests__/python/test_source_routing.py -v
    # All existing tests still pass
    uv run pytest --tb=short -q
    ```
  </verify>
  <done>All source adapter and routing tests pass. No regressions in existing test suite.</done>
</task>

</tasks>

<verification>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp

# All tests pass
uv run pytest -v --tb=short

# Build succeeds
npm run build

# Jest tests pass
node --experimental-vm-modules node_modules/jest/bin/jest.js --passWithNoTests

# New test files exist and pass
uv run pytest __tests__/python/test_source_adapters.py -v
uv run pytest __tests__/python/test_source_routing.py -v
```
</verification>

<success_criteria>
- Parallel mode queries both sources concurrently
- MD5-based deduplication works correctly
- Partial failure in parallel mode returns results from healthy source
- All unit tests pass (adapters + routing + existing)
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/12-annas-archive/12-03-SUMMARY.md`
</output>
