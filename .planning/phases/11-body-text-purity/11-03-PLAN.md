---
phase: 11-body-text-purity
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - lib/rag/detection/footnotes.py
  - lib/rag/detection/margins.py
  - lib/rag/detection/headings.py
  - lib/rag/detection/page_numbers.py
  - lib/rag/detection/toc.py
  - lib/rag/detection/front_matter.py
autonomous: true

must_haves:
  truths:
    - "All 6 detectors register via @register_detector decorator with appropriate priority and scope"
    - "Page-level detectors (footnotes, margins) return DetectionResult with BlockClassification list including bboxes"
    - "Document-level detectors (headings, page_numbers, toc, front_matter) return DetectionResult with classifications"
    - "Existing detector functions still work independently (backward compat)"
    - "Footnote detector stores bboxes in context for margin detector dedup (MARG-FOOTNOTE-DEDUP-DEFERRED)"
  artifacts:
    - path: "lib/rag/detection/footnotes.py"
      provides: "Registered footnote detector adapter"
      contains: "register_detector"
    - path: "lib/rag/detection/margins.py"
      provides: "Registered margin detector adapter with excluded_bboxes from context"
      contains: "register_detector"
    - path: "lib/rag/detection/headings.py"
      provides: "Registered heading detector adapter"
      contains: "register_detector"
    - path: "lib/rag/detection/page_numbers.py"
      provides: "Registered page number detector adapter"
      contains: "register_detector"
    - path: "lib/rag/detection/toc.py"
      provides: "Registered TOC detector adapter"
      contains: "register_detector"
    - path: "lib/rag/detection/front_matter.py"
      provides: "Registered front matter detector adapter"
      contains: "register_detector"
  key_links:
    - from: "lib/rag/detection/margins.py"
      to: "context['footnote_bboxes']"
      via: "reads excluded bboxes from pipeline context"
      pattern: "footnote_bboxes"
    - from: "lib/rag/detection/footnotes.py"
      to: "context['footnote_bboxes']"
      via: "writes detected footnote bboxes to pipeline context"
      pattern: "footnote_bboxes"
---

<objective>
Wrap all 6 existing detectors with registry adapter functions that convert their ad-hoc return types into typed DetectionResult objects with BlockClassification entries.

Purpose: Bridge existing detector implementations to the new pipeline contract without rewriting detection logic. Resolves MARG-FOOTNOTE-DEDUP-DEFERRED by wiring footnote bboxes through pipeline context.
Output: 6 detector modules updated with @register_detector adapters

Note: 6 files across 2 tasks is borderline scope. Task 1 (page-level: 2 files) and Task 2 (document-level: 4 files) are cleanly separated. Each adapter is boilerplate (~20 lines), so total implementation is light despite file count. If executor hits context pressure, Task 2 can be deferred to a follow-up plan.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/11-body-text-purity/11-RESEARCH.md
@.planning/phases/11-body-text-purity/11-01-SUMMARY.md
@lib/rag/detection/footnote_core.py
@lib/rag/detection/margins.py
@lib/rag/detection/headings.py
@lib/rag/detection/page_numbers.py
@lib/rag/detection/toc.py
@lib/rag/detection/front_matter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap page-level detectors (footnotes + margins)</name>
  <files>lib/rag/detection/footnotes.py, lib/rag/detection/margins.py</files>
  <action>
**Footnotes** (`lib/rag/detection/footnotes.py`):
Add a registered adapter function at module level (do NOT modify existing detection functions):

```python
@register_detector("footnotes", priority=10, scope=DetectorScope.PAGE)
def detect_footnotes_pipeline(page, page_num, context):
    """Pipeline adapter for footnote detection."""
    result = _detect_footnotes_in_page(page, page_num - 1)  # existing uses 0-indexed
    classifications = []
    for defn in result.get("definitions", []):
        classifications.append(BlockClassification(
            bbox=tuple(defn["bbox"]),
            content_type=ContentType.FOOTNOTE,
            text=defn.get("text", ""),
            confidence=defn.get("classification_confidence", 0.8),
            detector_name="footnotes",
            page_num=page_num,
            metadata={"marker": defn.get("marker"), "note_type": defn.get("note_type")}
        ))
    # Store bboxes in context for downstream detectors (margin dedup)
    context["footnote_bboxes"] = [tuple(d["bbox"]) for d in result.get("definitions", [])]
    return DetectionResult(detector_name="footnotes", classifications=classifications, page_num=page_num, metadata=result)
```

Priority 10 ensures footnotes run BEFORE margins (priority 20).

**Margins** (`lib/rag/detection/margins.py`):
Add a registered adapter that reads `context["footnote_bboxes"]` and passes as `excluded_bboxes`:

```python
@register_detector("margins", priority=20, scope=DetectorScope.PAGE)
def detect_margins_pipeline(page, page_num, context):
    """Pipeline adapter for margin detection. Excludes footnote bboxes."""
    excluded = context.get("footnote_bboxes", [])
    result = detect_margin_content(page, excluded_bboxes=excluded)
    classifications = []
    for block in result.get("margin_blocks", []):
        classifications.append(BlockClassification(
            bbox=tuple(block["bbox"]),
            content_type=ContentType.MARGIN,
            text=block.get("text", ""),
            confidence=0.8,  # margins don't have confidence yet; default
            detector_name="margins",
            page_num=page_num,
            metadata={"margin_type": block.get("type"), "reference_system": block.get("reference_system")}
        ))
    return DetectionResult(detector_name="margins", classifications=classifications, page_num=page_num, metadata=result)
```

Add necessary imports at top of each file: `from lib.rag.detection.registry import register_detector` and `from lib.rag.pipeline.models import ...`.

CRITICAL: Do NOT modify any existing function signatures or behavior. Only ADD the adapter functions.
  </action>
  <verify>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp
uv run python -c "
from lib.rag.detection.registry import get_registered_detectors, clear_registry
# Importing the modules triggers registration
import lib.rag.detection.footnotes
import lib.rag.detection.margins
detectors = get_registered_detectors()
names = [d['name'] for d in detectors]
assert 'footnotes' in names, f'footnotes not registered: {names}'
assert 'margins' in names, f'margins not registered: {names}'
# Footnotes should have lower priority (runs first)
fn = next(d for d in detectors if d['name'] == 'footnotes')
mg = next(d for d in detectors if d['name'] == 'margins')
assert fn['priority'] < mg['priority'], 'Footnotes must run before margins'
print('Page-level detector registration OK')
"
```
  </verify>
  <done>Footnotes and margins registered with correct priorities; footnote bboxes flow to margins via context; existing functions unmodified</done>
</task>

<task type="auto">
  <name>Task 2: Wrap document-level detectors (headings, page_numbers, toc, front_matter)</name>
  <files>lib/rag/detection/headings.py, lib/rag/detection/page_numbers.py, lib/rag/detection/toc.py, lib/rag/detection/front_matter.py</files>
  <action>
For each document-level detector, add a registered adapter at module level. These use `scope=DetectorScope.DOCUMENT` and receive `(doc, context)` instead of `(page, page_num, context)`.

**Headings** (`headings.py`, priority=30):
- Call existing heading detection function
- Convert results to BlockClassification with ContentType.HEADING
- Headings stay in body (per CONTEXT.md) â€” classifications are informational, not for removal
- Set metadata with heading level

**Page Numbers** (`page_numbers.py`, priority=5):
- Call `infer_written_page_numbers(doc)`
- Store result in context as `context["page_number_map"]`
- Return DetectionResult with page_num=0 (document-level)
- Each page number becomes a BlockClassification with ContentType.PAGE_NUMBER

**TOC** (`toc.py`, priority=15):
- Call existing `_extract_toc_from_pdf(doc)` or equivalent
- Store result in context as `context["toc_map"]`
- Return DetectionResult with ContentType.TOC classifications

**Front Matter** (`front_matter.py`, priority=25):
- Call existing front matter detection
- Store result in context as `context["front_matter"]`
- Return DetectionResult with ContentType.FRONT_MATTER classifications
- Front matter pages will be stripped from body by the compositor

All adapters: Add necessary imports. Do NOT modify existing functions. Adapters are additive only.

For document-level detectors that don't have bbox information (headings, TOC), use `bbox=(0, 0, 0, 0)` as a sentinel value and note in metadata that bbox is not available.
  </action>
  <verify>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp
uv run python -c "
from lib.rag.detection.registry import get_registered_detectors, clear_registry
from lib.rag.pipeline.models import DetectorScope
# Import all detection modules to trigger registration
import lib.rag.detection.headings
import lib.rag.detection.page_numbers
import lib.rag.detection.toc
import lib.rag.detection.front_matter
doc_detectors = get_registered_detectors(scope=DetectorScope.DOCUMENT)
names = [d['name'] for d in doc_detectors]
for expected in ['headings', 'page_numbers', 'toc', 'front_matter']:
    assert expected in names, f'{expected} not registered: {names}'
print(f'All 4 document-level detectors registered: {names}')
# Verify priority ordering
for d in doc_detectors:
    print(f'  {d[\"name\"]}: priority={d[\"priority\"]}')
"
```
  </verify>
  <done>All 4 document-level detectors registered with scope=DOCUMENT; existing functions unmodified; pipeline context populated with toc_map, page_number_map, front_matter</done>
</task>

</tasks>

<verification>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp
uv run python -c "
from lib.rag.detection.registry import get_registered_detectors
# Import all to trigger registration
import lib.rag.detection.footnotes
import lib.rag.detection.margins
import lib.rag.detection.headings
import lib.rag.detection.page_numbers
import lib.rag.detection.toc
import lib.rag.detection.front_matter
all_d = get_registered_detectors()
print(f'Total registered detectors: {len(all_d)}')
assert len(all_d) == 6, f'Expected 6 detectors, got {len(all_d)}'
for d in all_d:
    print(f'  {d[\"name\"]}: priority={d[\"priority\"]}, scope={d[\"scope\"]}')
"
# Existing tests still pass
uv run pytest __tests__/python/ -x --tb=short -q 2>&1 | tail -5
```
</verification>

<success_criteria>
- All 6 detectors registered (2 page-level, 4 document-level)
- Priority ordering: page_numbers(5) < footnotes(10) < toc(15) < margins(20) < front_matter(25) < headings(30)
- Footnote bboxes stored in context for margin dedup (MARG-FOOTNOTE-DEDUP-DEFERRED resolved)
- All existing tests pass (no behavioral changes to existing functions)
</success_criteria>

<output>
After completion, create `.planning/phases/11-body-text-purity/11-03-SUMMARY.md`
</output>
