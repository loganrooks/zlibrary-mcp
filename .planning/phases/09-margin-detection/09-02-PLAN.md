---
phase: 09-margin-detection
plan: 02
type: tdd
wave: 2
depends_on: ["09-01"]
files_modified:
  - lib/rag/detection/margin_patterns.py
  - __tests__/python/test_margin_patterns.py
autonomous: true

must_haves:
  truths:
    - "Stephanus references (e.g., '231a', '514b-c') are recognized and typed as stephanus"
    - "Bekker references (e.g., '1094a1', '1140b5') are recognized and typed as bekker"
    - "Line numbers (standalone integers in margin zones) are recognized and typed as line_number"
    - "Unrecognized margin content defaults to generic 'margin' type"
    - "Pattern matching operates on MarginBlock text from 09-01 detection output"
  artifacts:
    - path: "lib/rag/detection/margin_patterns.py"
      provides: "Scholarly reference pattern classification"
      exports: ["classify_margin_content", "MarginContentType"]
      min_lines: 60
    - path: "__tests__/python/test_margin_patterns.py"
      provides: "Unit tests for pattern classification"
      min_lines: 60
  key_links:
    - from: "lib/rag/detection/margin_patterns.py"
      to: "lib/rag/detection/margins.py"
      via: "Consumes MarginBlock objects"
      pattern: "from lib.rag.detection.margins import"
---

<objective>
Build scholarly reference pattern classifiers that type-classify margin content detected by 09-01 into Stephanus, Bekker, line numbers, or generic margin.

Purpose: Roadmap success criterion #2 requires Stephanus/Bekker as structured annotations, not just generic margin markers.
Output: `lib/rag/detection/margin_patterns.py` with `classify_margin_content()` and tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-margin-detection/09-RESEARCH.md
@.planning/phases/09-margin-detection/09-01-SUMMARY.md
@lib/rag/detection/margins.py
</context>

<feature>
  <name>Scholarly Reference Pattern Classification</name>
  <files>lib/rag/detection/margin_patterns.py, __tests__/python/test_margin_patterns.py</files>
  <behavior>
    Given a MarginBlock (from 09-01), classify_margin_content() returns a MarginContentType enum and optionally a normalized reference string.

    Classification rules (checked in order, first match wins):
    1. Stephanus: matches pattern \b\d{2,3}[a-e](-[a-e])?\b → MarginContentType.STEPHANUS
       Examples: "231a", "514b-c", "100d", "45e"
    2. Bekker: matches pattern \b\d{3,4}[ab]\d{1,2}\b → MarginContentType.BEKKER
       Examples: "1094a1", "1140b5", "980b20"
    3. Line number: matches pattern ^\s*\d{1,5}\s*$ (standalone integer) → MarginContentType.LINE_NUMBER
       Examples: "5", "10", "255", "1000"
    4. Default: anything else → MarginContentType.MARGIN (generic)
       Examples: "cf. Book III", "see also p.45", "gloss text"

    Test cases:
    - "231a" → STEPHANUS, ref="231a"
    - "514b-c" → STEPHANUS, ref="514b-c"
    - "1094a1" → BEKKER, ref="1094a1"
    - "1140b5" → BEKKER, ref="1140b5"
    - "  25  " → LINE_NUMBER, ref="25"
    - "cf. Book III" → MARGIN (generic)
    - "231a some gloss text" → MARGIN (generic, not pure Stephanus)
    - "" (empty) → MARGIN (generic)
    - "5a" → STEPHANUS (2-digit + letter matches Stephanus)
    - "12345" → LINE_NUMBER (5-digit)
    - "123456" → MARGIN (6-digit exceeds line number range)
  </behavior>
  <implementation>
    Create lib/rag/detection/margin_patterns.py:

    1. Define MarginContentType enum: STEPHANUS, BEKKER, LINE_NUMBER, MARGIN

    2. Define compiled regex patterns at module level:
       - STEPHANUS_RE = re.compile(r'^\s*(\d{2,3}[a-e](?:-[a-e])?)\s*$')
       - BEKKER_RE = re.compile(r'^\s*(\d{3,4}[ab]\d{1,2})\s*$')
       - LINE_NUMBER_RE = re.compile(r'^\s*(\d{1,5})\s*$')
       Note: patterns use ^ and $ to require the ENTIRE margin text to match (not substring)

    3. Implement classify_margin_content(text: str) -> tuple[MarginContentType, str]:
       - Strip and check patterns in order: Stephanus → Bekker → Line number → Generic
       - Return (type, normalized_reference_string)
       - For generic: return (MARGIN, original_text)

    4. Implement classify_margin_blocks(margin_blocks: list[MarginBlock]) -> list[ClassifiedMarginBlock]:
       - Batch classification convenience function
       - Returns new dataclass with original MarginBlock + content_type + reference

    Use only stdlib (re, enum). No new dependencies.
  </implementation>
</feature>

<verification>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp
uv run pytest __tests__/python/test_margin_patterns.py -v
```

All tests pass. Module importable: `python -c "from lib.rag.detection.margin_patterns import classify_margin_content, MarginContentType"`
</verification>

<success_criteria>
- Stephanus patterns correctly identified with 2-3 digit + letter format
- Bekker patterns correctly identified with 3-4 digit + letter + digit format
- Line numbers (standalone integers up to 5 digits) correctly identified
- Mixed content (reference + gloss) falls through to generic
- Empty/whitespace input handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/09-margin-detection/09-02-SUMMARY.md`
</output>
