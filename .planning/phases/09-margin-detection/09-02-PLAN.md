---
phase: 09-margin-detection
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - lib/rag/orchestrator_pdf.py
  - lib/rag/processors/pdf.py
autonomous: true

must_haves:
  truths:
    - "Margin detection runs in the page processing loop before body text formatting"
    - "Margin blocks are excluded from body text output in _format_pdf_markdown"
    - "Typed annotations ({{stephanus:}}, {{bekker:}}, {{line_number:}}, {{margin:}}) appear inline adjacent to nearest body text"
    - "Existing footnote, heading, and page number detection still works correctly"
  artifacts:
    - path: "lib/rag/orchestrator_pdf.py"
      provides: "detect_margin_content call in page loop"
      contains: "detect_margin_content"
    - path: "lib/rag/processors/pdf.py"
      provides: "margin_blocks parameter in _format_pdf_markdown, margin_map integration in block loop"
      contains: "margin_blocks"
  key_links:
    - from: "lib/rag/orchestrator_pdf.py"
      to: "lib/rag/detection/margins.py"
      via: "detect_margin_content import and call"
      pattern: "from lib.rag.detection.margins import detect_margin_content"
    - from: "lib/rag/orchestrator_pdf.py"
      to: "lib/rag/processors/pdf.py"
      via: "margin_blocks parameter passed to _format_pdf_markdown"
      pattern: "margin_blocks=.*margin"
    - from: "lib/rag/processors/pdf.py"
      to: "lib/rag/detection/margin_patterns.py"
      via: "classify_margin_content for annotation generation"
      pattern: "classify_margin_content"
---

<objective>
Integrate margin detection into the PDF processing pipeline so margin content is detected, excluded from body text, and emitted as typed inline annotations.

Purpose: Wire the detection engine (from Plan 01) into the existing orchestrator and formatter. This satisfies MARG-07 (preserve margin content as structured annotations in markdown output) and ensures margin content doesn't pollute body text.

Output: Modified orchestrator_pdf.py and pdf.py with margin detection integrated into the page processing flow.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-margin-detection/09-RESEARCH.md
@.planning/phases/09-margin-detection/09-01-SUMMARY.md

# Integration targets:
@lib/rag/orchestrator_pdf.py
@lib/rag/processors/pdf.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate margin detection into orchestrator page loop</name>
  <files>lib/rag/orchestrator_pdf.py</files>
  <action>
In `orchestrator_pdf.py`, the page processing loop is at lines 322-416. After existing detection calls (footnotes at ~line 334), add margin detection:

1. Add import at top: `from lib.rag.detection.margins import detect_margin_content`

2. Inside the page loop, AFTER footnote detection and BEFORE `_format_md` call (~line 379-391):
```python
# Detect margin content
margin_result = detect_margin_content(page, excluded_bboxes=footnote_bboxes_set)
margin_blocks = margin_result.get('margin_blocks', [])
```

Note: `footnote_bboxes_set` — check what footnote detection returns. If it returns block bboxes, pass them. If not available, pass `None`. The goal is to avoid double-classifying footnote blocks as margin content. If there's no clean way to get footnote bboxes at this point, pass `None` and add a TODO for Phase 11 deduplication.

3. Pass `margin_blocks` to the `_format_md` call:
```python
page_markdown = _format_md(
    page,
    # ... existing params ...
    margin_blocks=margin_blocks,  # NEW
)
```

**Cache discrepancy investigation**: Before integrating, check empirically whether `_get_cached_text_blocks(page, "dict")` and `page.get_text("dict", flags=fitz.TEXTFLAGS_DICT).get("blocks", [])` return identical structures. Add a brief comment documenting the finding. If they differ, have `detect_margin_content` use the same direct extraction as `_format_pdf_markdown` for consistency.
  </action>
  <verify>
```bash
# Build succeeds
uv run python -c "from lib.rag.orchestrator_pdf import process_pdf; print('import OK')"

# Existing tests still pass
uv run pytest __tests__/python/ -v --timeout=60
```
  </verify>
  <done>orchestrator_pdf.py calls detect_margin_content in the page loop and passes margin_blocks to _format_pdf_markdown. Cache discrepancy documented.</done>
</task>

<task type="auto">
  <name>Task 2: Add margin_blocks handling to _format_pdf_markdown</name>
  <files>lib/rag/processors/pdf.py</files>
  <action>
Modify `_format_pdf_markdown` in `lib/rag/processors/pdf.py`:

1. **Add parameter**: Add `margin_blocks: list = None` to function signature (line 29-41).

2. **Build margin_map before main loop** (before line 100):
```python
# Build margin-to-body association map
margin_map = {}  # body_block_idx -> list of "{{type: content}}" annotation strings
margin_bbox_set = set()
if margin_blocks:
    from lib.rag.detection.margin_patterns import classify_margin_content
    # Get body-only blocks (exclude margin blocks)
    margin_bbox_set = {tuple(mb['bbox']) for mb in margin_blocks}
    body_only_blocks = [b for b in blocks if b.get("type") == 0 and tuple(b["bbox"]) not in margin_bbox_set]

    for mb in margin_blocks:
        mtype = mb.get('type', 'margin')
        mcontent = mb.get('content', mb.get('text', ''))
        annotation = f"{{{{{mtype}: {mcontent}}}}}"
        # Associate with nearest body block by y-center overlap
        idx = _associate_margin_to_body(mb['bbox'], body_only_blocks)
        margin_map.setdefault(idx, []).append(annotation)
```

3. **Add helper function** `_associate_margin_to_body(margin_bbox, body_blocks) -> int` (as module-level function, following research Pattern 5):
- Find body block with closest y-center to margin block y-center
- Direct y-overlap returns immediately
- Otherwise return nearest by y-distance

4. **In the main block loop** (line 100-235):
- Skip blocks whose bbox is in `margin_bbox_set` (they're margin, not body)
- After appending body text for a block, check `if text_block_idx in margin_map:` and append each annotation string

5. **Ensure text_block_idx tracking is correct**: The existing loop increments `text_block_idx` for body blocks. Margin blocks should NOT increment this counter since they're skipped.
  </action>
  <verify>
```bash
# Import succeeds
uv run python -c "from lib.rag.processors.pdf import _format_pdf_markdown; print('OK')"

# All tests pass
uv run pytest __tests__/python/ -v --timeout=60
```
  </verify>
  <done>_format_pdf_markdown accepts margin_blocks, skips them from body output, and inserts typed {{type: content}} annotations adjacent to nearest body text. Existing formatting behavior unchanged when margin_blocks is None.</done>
</task>

</tasks>

<verification>
```bash
# All existing tests still pass (critical — no regressions)
uv run pytest __tests__/python/ -v --timeout=60

# Margin detection imports work end-to-end
uv run python -c "
from lib.rag.detection.margins import detect_margin_content
from lib.rag.processors.pdf import _format_pdf_markdown
print('Pipeline imports OK')
"

# Build TypeScript (ensure no breaks)
cd /home/rookslog/workspace/projects/zlibrary-mcp && npm run build
```
</verification>

<success_criteria>
- orchestrator_pdf.py calls detect_margin_content in page loop
- _format_pdf_markdown has margin_blocks parameter and margin_map logic
- Margin blocks are excluded from body text output
- Typed annotations appear inline after nearest body text block
- All existing tests pass with zero regressions
- Cache discrepancy investigated and documented
</success_criteria>

<output>
After completion, create `.planning/phases/09-margin-detection/09-02-SUMMARY.md`
</output>
