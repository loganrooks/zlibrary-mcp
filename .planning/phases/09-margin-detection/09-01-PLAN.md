---
phase: 09-margin-detection
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/rag/detection/margins.py
  - __tests__/python/test_margin_detection.py
autonomous: true

must_haves:
  truths:
    - "Text blocks outside the inferred body column are classified as margin content"
    - "Body column boundaries adapt per page based on block position clustering"
    - "Header/footer zones (top/bottom 8-10%) are excluded from margin classification"
    - "Two-column layouts are detected and not misclassified as body+margin"
    - "Adjacent narrow margin blocks are merged before text extraction"
  artifacts:
    - path: "lib/rag/detection/margins.py"
      provides: "Margin zone detection engine"
      exports: ["detect_margin_zones", "MarginBlock", "MarginDetectionResult"]
      min_lines: 100
    - path: "__tests__/python/test_margin_detection.py"
      provides: "Unit tests for margin detection"
      min_lines: 80
  key_links:
    - from: "lib/rag/detection/margins.py"
      to: "fitz.Page"
      via: "page.get_text('dict') and page.rect"
      pattern: "get_text.*dict"
---

<objective>
Build the margin zone detection engine that classifies PDF text blocks as body or margin content using statistical body-column inference from bbox coordinates.

Purpose: Foundation for all margin content handling — detection must work before classification or annotation can happen.
Output: `lib/rag/detection/margins.py` with `detect_margin_zones()` function and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-margin-detection/09-RESEARCH.md
@lib/rag/detection/footnote_core.py
@lib/rag/detection/page_numbers.py
</context>

<feature>
  <name>Margin Zone Detection Engine</name>
  <files>lib/rag/detection/margins.py, __tests__/python/test_margin_detection.py</files>
  <behavior>
    Given a fitz.Page object, detect_margin_zones() returns a MarginDetectionResult containing:
    - body_blocks: list of text blocks classified as body content
    - margin_blocks: list of MarginBlock objects (block + zone label + text)
    - body_left/body_right: inferred body column boundaries

    Classification logic:
    1. Extract all text blocks via page.get_text("dict")
    2. Exclude header zone (top 8%) and footer zone (bottom 8%) by y-coordinate
    3. Histogram-bin left edges and right edges (5pt bins) to find dominant body column
    4. Detect two-column layouts: if left-edge histogram has 2 peaks with >30% of blocks each, treat as two-column (widen body zone to encompass both)
    5. Classify blocks: center_x < body_left → margin-left, center_x > body_right → margin-right, else body
    6. Merge adjacent margin blocks (within 5pt vertically, same lateral zone) before extracting text
    7. Associate each margin block with nearest body block by y-coordinate overlap

    Test cases:
    - Single-column page with left margin numbers → numbers classified as margin-left
    - Single-column page with right margin notes → notes classified as margin-right
    - Two-column page → both columns classified as body, no false margin detection
    - Page with header/footer text → header/footer excluded from margin detection
    - Empty page / no text blocks → returns empty result gracefully
    - Narrow margin blocks adjacent vertically → merged into single margin block
    - Block with center_x on body boundary → classified as body (tolerance)
  </behavior>
  <implementation>
    Create lib/rag/detection/margins.py following the detection module pattern from footnote_core.py:

    1. Define data classes:
       - MarginBlock: block dict, zone ("margin-left"/"margin-right"), extracted text, bbox, associated_body_idx
       - MarginDetectionResult: body_blocks list, margin_blocks list, body_left float, body_right float

    2. Implement _infer_body_column(text_blocks, page_rect) -> (body_left, body_right):
       - Histogram-bin left/right edges at 5pt resolution
       - Most common left edge = body_left, most common right edge = body_right
       - Fallback: 15% margins if no blocks
       - Two-column detection: if two left-edge peaks each have >30% of blocks, widen body zone

    3. Implement _classify_block_zone(bbox, body_left, body_right, page_rect, header_pct=0.08, footer_pct=0.08) -> str:
       - Returns "header", "footer", "margin-left", "margin-right", or "body"
       - Uses center_x for lateral classification with 5pt tolerance

    4. Implement _merge_adjacent_margins(margin_blocks) -> list:
       - Merge blocks in same zone within 5pt vertically
       - Concatenate text with space separator

    5. Implement _associate_margin_to_body(margin_block, body_blocks) -> int:
       - Find body block with best y-coordinate overlap
       - Direct overlap returns immediately; otherwise nearest by y-distance

    6. Implement detect_margin_zones(page, excluded_blocks=None) -> MarginDetectionResult:
       - Main entry point
       - excluded_blocks parameter allows skipping blocks already claimed by page_numbers/footnotes
       - Orchestrates: extract blocks → filter excluded → infer column → classify → merge → associate

    Use only stdlib + PyMuPDF (already installed). Follow existing detection module patterns (logging, __all__ exports).
  </implementation>
</feature>

<verification>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp
uv run pytest __tests__/python/test_margin_detection.py -v
```

All tests pass. The module can be imported: `python -c "from lib.rag.detection.margins import detect_margin_zones"`
</verification>

<success_criteria>
- detect_margin_zones() correctly classifies blocks as body/margin on synthetic test data
- Two-column detection prevents false margin classification
- Header/footer zones excluded
- Adjacent margin blocks merged
- Module follows existing detection pattern (logging, __all__, type hints)
</success_criteria>

<output>
After completion, create `.planning/phases/09-margin-detection/09-01-SUMMARY.md`
</output>
