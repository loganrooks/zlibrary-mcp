---
phase: 12-annas-archive
plan: 04
type: execute
wave: 3
depends_on: ["12-02", "12-03"]
files_modified:
  - lib/sources/router.py
  - lib/sources/__init__.py
  - lib/python_bridge.py
  - __tests__/python/test_source_router.py
autonomous: true

must_haves:
  truths:
    - "Router search() returns results with source field indicating origin"
    - "Router fallback activates when Anna's quota exhausted or on error"
    - "Router respects source parameter: 'auto', 'annas', 'libgen'"
    - "python_bridge search functions use router for multi-source search"
  artifacts:
    - path: "lib/sources/router.py"
      provides: "SourceRouter with fallback logic"
      exports: ["SourceRouter"]
      min_lines: 100
    - path: "__tests__/python/test_source_router.py"
      provides: "Integration tests for source router"
      contains: "test_fallback_on_quota_exhausted"
  key_links:
    - from: "lib/sources/router.py"
      to: "lib/sources/annas.py"
      via: "Creates and uses AnnasArchiveAdapter"
      pattern: "AnnasArchiveAdapter"
    - from: "lib/sources/router.py"
      to: "lib/sources/libgen.py"
      via: "Creates and uses LibgenAdapter for fallback"
      pattern: "LibgenAdapter"
    - from: "lib/python_bridge.py"
      to: "lib/sources/router.py"
      via: "Uses SourceRouter for search operations"
      pattern: "from lib.sources.router import"
---

<objective>
Create source router with fallback logic and integrate into python_bridge.py for multi-source book search.

Purpose: Enable automatic source switching when Anna's quota is exhausted, with clear source attribution in results. Complete the Anna's Archive integration.
Output: lib/sources/router.py wired into python_bridge.py, all phase success criteria verified
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-annas-archive/12-CONTEXT.md
@.planning/phases/12-annas-archive/12-RESEARCH.md
@.planning/phases/12-annas-archive/12-02-SUMMARY.md
@.planning/phases/12-annas-archive/12-03-SUMMARY.md
@lib/python_bridge.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create source router with fallback logic</name>
  <files>lib/sources/router.py</files>
  <action>
Create lib/sources/router.py with SourceRouter class:

```python
import logging
from typing import List, Optional, Literal

from .models import UnifiedBookResult, DownloadResult, SourceType
from .config import SourceConfig, get_source_config
from .annas import AnnasArchiveAdapter, QuotaExhaustedError
from .libgen import LibgenAdapter

logger = logging.getLogger("zlibrary.sources")

SourceSelection = Literal["auto", "annas", "libgen"]

class SourceRouter:
    """Routes search and download requests to appropriate source with fallback."""

    def __init__(self, config: Optional[SourceConfig] = None):
        self.config = config or get_source_config()
        self._annas: Optional[AnnasArchiveAdapter] = None
        self._libgen: Optional[LibgenAdapter] = None

    def _get_annas(self) -> Optional[AnnasArchiveAdapter]:
        if self._annas is None and self.config.has_annas_key:
            self._annas = AnnasArchiveAdapter(self.config)
        return self._annas

    def _get_libgen(self) -> LibgenAdapter:
        if self._libgen is None:
            self._libgen = LibgenAdapter(self.config)
        return self._libgen

    def _determine_source(self, source: SourceSelection) -> SourceSelection:
        """Determine actual source based on config and availability."""
        if source == "auto":
            return "annas" if self.config.has_annas_key else "libgen"
        return source

    async def search(
        self,
        query: str,
        source: SourceSelection = "auto",
        **kwargs
    ) -> List[UnifiedBookResult]:
        """
        Search for books with automatic fallback.

        Args:
            query: Search query
            source: 'auto', 'annas', or 'libgen'

        Returns:
            List of UnifiedBookResult with source field set
        """
        actual_source = self._determine_source(source)

        if actual_source == "annas":
            annas = self._get_annas()
            if annas:
                try:
                    results = await annas.search(query, **kwargs)
                    if results:
                        return results
                    logger.info("Anna's Archive returned no results")
                except Exception as e:
                    logger.warning(f"Anna's Archive search failed: {e}")

                # Fallback to LibGen if enabled
                if self.config.fallback_enabled:
                    logger.info("Falling back to LibGen")
                    return await self._get_libgen().search(query, **kwargs)
                return []

        # Direct LibGen search
        return await self._get_libgen().search(query, **kwargs)

    async def get_download_url(
        self,
        md5: str,
        source: SourceSelection = "auto",
    ) -> DownloadResult:
        """
        Get download URL with automatic fallback on quota exhaustion.

        Args:
            md5: Book MD5 hash
            source: 'auto', 'annas', or 'libgen'

        Returns:
            DownloadResult with URL and quota info (if Anna's)
        """
        actual_source = self._determine_source(source)

        if actual_source == "annas":
            annas = self._get_annas()
            if annas:
                try:
                    result = await annas.get_download_url(md5)
                    # Check quota - if 0 left, raise for fallback
                    if result.quota_info and result.quota_info.downloads_left == 0:
                        raise QuotaExhaustedError("Anna's Archive quota exhausted")
                    return result
                except QuotaExhaustedError:
                    if self.config.fallback_enabled:
                        logger.warning("Anna's Archive quota exhausted, falling back to LibGen")
                        return await self._get_libgen().get_download_url(md5)
                    raise
                except Exception as e:
                    if self.config.fallback_enabled:
                        logger.warning(f"Anna's Archive download failed: {e}, falling back to LibGen")
                        return await self._get_libgen().get_download_url(md5)
                    raise

        return await self._get_libgen().get_download_url(md5)

    async def close(self) -> None:
        """Clean up all adapters."""
        if self._annas:
            await self._annas.close()
        if self._libgen:
            await self._libgen.close()
```

Also add QuotaExhaustedError to lib/sources/annas.py if not already present.
Update lib/sources/__init__.py to export SourceRouter.
  </action>
  <verify>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp && uv run python -c "
from lib.sources import SourceRouter
from lib.sources.config import SourceConfig

config = SourceConfig(annas_secret_key='', default_source='auto')
router = SourceRouter(config)
print(f'Router created, has_annas_key={config.has_annas_key}')
"
```
  </verify>
  <done>SourceRouter can be instantiated and respects config.has_annas_key for source selection</done>
</task>

<task type="auto">
  <name>Task 2: Create router integration tests</name>
  <files>__tests__/python/test_source_router.py</files>
  <action>
Create comprehensive tests for SourceRouter:

```python
import pytest
from unittest.mock import AsyncMock, patch, MagicMock
from lib.sources.router import SourceRouter
from lib.sources.config import SourceConfig
from lib.sources.models import UnifiedBookResult, DownloadResult, QuotaInfo, SourceType
from lib.sources.annas import QuotaExhaustedError

@pytest.fixture
def config_with_annas():
    return SourceConfig(
        annas_secret_key="test-key",
        fallback_enabled=True,
    )

@pytest.fixture
def config_without_annas():
    return SourceConfig(
        annas_secret_key="",
        fallback_enabled=True,
    )

class TestSourceRouter:
    @pytest.mark.asyncio
    async def test_auto_uses_annas_when_key_present(self, config_with_annas):
        router = SourceRouter(config_with_annas)
        assert router._determine_source("auto") == "annas"

    @pytest.mark.asyncio
    async def test_auto_uses_libgen_when_no_key(self, config_without_annas):
        router = SourceRouter(config_without_annas)
        assert router._determine_source("auto") == "libgen"

    @pytest.mark.asyncio
    async def test_search_returns_results_with_source(self, config_with_annas):
        router = SourceRouter(config_with_annas)
        mock_result = [UnifiedBookResult(md5="abc", title="Test", source=SourceType.ANNAS_ARCHIVE)]

        with patch.object(router, '_get_annas') as mock_annas:
            mock_adapter = AsyncMock()
            mock_adapter.search.return_value = mock_result
            mock_annas.return_value = mock_adapter

            results = await router.search("test")
            assert len(results) == 1
            assert results[0].source == SourceType.ANNAS_ARCHIVE

    @pytest.mark.asyncio
    async def test_fallback_on_annas_failure(self, config_with_annas):
        router = SourceRouter(config_with_annas)
        libgen_result = [UnifiedBookResult(md5="def", title="Fallback", source=SourceType.LIBGEN)]

        with patch.object(router, '_get_annas') as mock_annas, \
             patch.object(router, '_get_libgen') as mock_libgen:
            annas_adapter = AsyncMock()
            annas_adapter.search.side_effect = Exception("Network error")
            mock_annas.return_value = annas_adapter

            libgen_adapter = AsyncMock()
            libgen_adapter.search.return_value = libgen_result
            mock_libgen.return_value = libgen_adapter

            results = await router.search("test")
            assert len(results) == 1
            assert results[0].source == SourceType.LIBGEN

    @pytest.mark.asyncio
    async def test_fallback_on_quota_exhausted(self, config_with_annas):
        router = SourceRouter(config_with_annas)

        with patch.object(router, '_get_annas') as mock_annas, \
             patch.object(router, '_get_libgen') as mock_libgen:
            annas_adapter = AsyncMock()
            annas_adapter.get_download_url.side_effect = QuotaExhaustedError("Quota exhausted")
            mock_annas.return_value = annas_adapter

            libgen_adapter = AsyncMock()
            libgen_adapter.get_download_url.return_value = DownloadResult(
                url="http://libgen.example/file.pdf",
                source=SourceType.LIBGEN,
            )
            mock_libgen.return_value = libgen_adapter

            result = await router.get_download_url("abc123")
            assert result.source == SourceType.LIBGEN
```
  </action>
  <verify>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp && uv run pytest __tests__/python/test_source_router.py -v
```
  </verify>
  <done>All router tests pass including fallback scenarios</done>
</task>

<task type="auto">
  <name>Task 3: Wire router into python_bridge.py</name>
  <files>lib/python_bridge.py</files>
  <action>
Update lib/python_bridge.py to use SourceRouter for multi-source search:

1. Add import at top (after existing imports):
```python
from lib.sources.router import SourceRouter
from lib.sources.config import get_source_config
```

2. Add module-level router variable:
```python
_source_router: SourceRouter = None
```

3. Add router initialization function:
```python
async def get_source_router() -> SourceRouter:
    """Get or create the source router."""
    global _source_router
    if _source_router is None:
        config = get_source_config()
        _source_router = SourceRouter(config)
    return _source_router
```

4. Add new search function for multi-source:
```python
async def search_multi_source(
    query: str,
    source: str = "auto",
    count: int = 10,
    **kwargs
) -> dict:
    """
    Search for books across multiple sources.

    Args:
        query: Search query
        source: 'auto', 'annas', or 'libgen'
        count: Max results

    Returns:
        dict with 'books' list and 'source' indicator
    """
    router = await get_source_router()
    results = await router.search(query, source=source)

    # Convert to dict format for JSON serialization
    books = [
        {
            "md5": r.md5,
            "title": r.title,
            "author": r.author,
            "year": r.year,
            "extension": r.extension,
            "size": r.size,
            "source": r.source.value,
            "download_url": r.download_url,
            **r.extra,
        }
        for r in results[:count]
    ]

    return {
        "books": books,
        "sources_used": list(set(b["source"] for b in books)),
    }
```

5. Add to main() function dispatch:
```python
elif function_name == "search_multi_source":
    result = await search_multi_source(**args_dict)
```

6. Update cleanup in finally block:
```python
finally:
    if _eapi_client:
        await _eapi_client.close()
    if _source_router:
        await _source_router.close()
```

Note: Keep existing search() function for backward compatibility with Z-Library EAPI. The new search_multi_source() provides alternative sources.
  </action>
  <verify>
```bash
cd /home/rookslog/workspace/projects/zlibrary-mcp && uv run python -c "
from lib.python_bridge import search_multi_source
import asyncio

# Test that function exists and can be called
result = asyncio.run(search_multi_source('test', source='libgen', count=1))
print(f'search_multi_source works: {len(result.get(\"books\", []))} books found')
"
```
  </verify>
  <done>python_bridge.py has search_multi_source function wired to SourceRouter</done>
</task>

</tasks>

<verification>
```bash
# Run all phase tests
cd /home/rookslog/workspace/projects/zlibrary-mcp && uv run pytest __tests__/python/test_annas_adapter.py __tests__/python/test_libgen_adapter.py __tests__/python/test_source_router.py -v

# Integration test with real sources (requires env vars)
cd /home/rookslog/workspace/projects/zlibrary-mcp && uv run python -c "
import asyncio
import os
from lib.sources.router import SourceRouter
from lib.sources.config import get_source_config

async def integration_test():
    config = get_source_config()
    print(f'Config: annas_key={'set' if config.has_annas_key else 'not set'}, fallback={config.fallback_enabled}')

    router = SourceRouter(config)
    try:
        # Test search
        results = await router.search('python', source='auto')
        print(f'Search: {len(results)} results')
        if results:
            for r in results[:3]:
                print(f'  [{r.source.value}] {r.title[:50]}...')

        # Verify source attribution
        sources = set(r.source.value for r in results)
        print(f'Sources used: {sources}')
    finally:
        await router.close()

asyncio.run(integration_test())
"

# Verify phase success criteria
echo "=== Phase 12 Success Criteria Verification ==="
echo "1. Anna's Archive search returns results with MD5: " && uv run python -c "
import asyncio
from lib.sources.annas import AnnasArchiveAdapter
from lib.sources.config import get_source_config
async def t():
    c = get_source_config()
    if c.has_annas_key:
        a = AnnasArchiveAdapter(c)
        r = await a.search('python')
        print(f'OK - {len(r)} results, first MD5: {r[0].md5[:8] if r else \"none\"}')
        await a.close()
    else:
        print('SKIP - no ANNAS_SECRET_KEY')
asyncio.run(t())
"

echo "2. Anna's Archive fast download uses domain_index=1:" && grep -n "domain_index.*1" lib/sources/annas.py && echo "OK"

echo "3. LibGen fallback available:" && uv run python -c "
from lib.sources.libgen import LibgenAdapter
print('OK - LibgenAdapter importable')
"

echo "4. Source indicator in results:" && uv run python -c "
from lib.sources.models import SourceType
print(f'OK - SourceType.ANNAS_ARCHIVE={SourceType.ANNAS_ARCHIVE.value}, SourceType.LIBGEN={SourceType.LIBGEN.value}')
"

echo "5. Configuration via env vars:" && uv run python -c "
from lib.sources.config import get_source_config
c = get_source_config()
print(f'OK - base_url={c.annas_base_url}, default={c.default_source}')
"
```
</verification>

<success_criteria>
1. SourceRouter routes search/download to appropriate adapter based on source parameter
2. Fallback to LibGen occurs when Anna's fails or quota exhausted
3. All results include source field ('annas_archive' or 'libgen')
4. python_bridge.py has search_multi_source function
5. Router tests pass including fallback scenarios
6. All phase success criteria verified
</success_criteria>

<output>
After completion, create `.planning/phases/12-annas-archive/12-04-SUMMARY.md`
</output>
