---
phase: 07-eapi-migration
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/python_bridge.py
  - __tests__/python/test_python_bridge.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Health check detects Cloudflare challenge responses"
    - "Health check returns specific error codes for different failure modes"
  artifacts:
    - path: "lib/python_bridge.py"
      provides: "Enhanced health check with Cloudflare detection"
      contains: "cloudflare_blocked"
  key_links:
    - from: "lib/python_bridge.py"
      to: "eapi_health_check"
      via: "Cloudflare pattern matching in response/exception"
      pattern: "cloudflare|checking.your.browser"
---

<objective>
Add Cloudflare challenge detection to EAPI health check.

Purpose: Close verification gap 2 — `eapi_health_check()` only validates EAPI response format but cannot detect the primary failure mode (Cloudflare "Checking your browser" challenges). This was the original cause of MCP server failure.
Output: Health check returns specific error codes: `cloudflare_blocked`, `network_error`, `malformed_response`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-eapi-migration/07-VERIFICATION.md
@lib/python_bridge.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance eapi_health_check with Cloudflare detection and error codes</name>
  <files>lib/python_bridge.py</files>
  <action>
Modify `eapi_health_check()` (line 239-270) to detect Cloudflare challenges and return specific error codes.

In the existing function:

1. After getting the response from `client.search("test", limit=1)`, check if the response contains Cloudflare indicators. The EAPI client uses httpx internally, but exceptions bubble up as standard Python exceptions. Cloudflare may manifest as:
   - An exception with "Checking your browser" or "cloudflare" in the message
   - A non-JSON response (HTML instead of JSON)
   - HTTP 403 or 503 status codes

2. In the exception handler, classify errors using ONLY built-in Python exceptions (do NOT import httpx):
   - If exception message contains "Checking your browser", "cloudflare", "cf-", or "challenge": return `error_code: "cloudflare_blocked"`
   - If exception is `ConnectionError` or `TimeoutError` (built-in Python types): return `error_code: "network_error"`
   - If response exists but is not valid JSON or missing expected fields: return `error_code: "malformed_response"`
   - Default: return `error_code: "unknown_error"`

3. Update the unhealthy response for non-success responses to include `error_code: "malformed_response"`.

4. Add a helper function `_classify_health_error(error: Exception) -> str` that returns the error code string. Pattern match on `str(error).lower()` for Cloudflare keywords first, then use `isinstance(error, (ConnectionError, TimeoutError, OSError))` for network errors. Do NOT reference httpx types — the built-in exception hierarchy covers these (httpx exceptions inherit from Python builtins).

Result structure for unhealthy responses:
```python
{
    'status': 'unhealthy',
    'transport': 'eapi',
    'error': str(e),
    'error_code': 'cloudflare_blocked' | 'network_error' | 'malformed_response' | 'unknown_error',
}
```
  </action>
  <verify>
Run: `cd /home/rookslog/workspace/projects/zlibrary-mcp && uv run python -c "import ast; ast.parse(open('lib/python_bridge.py').read()); print('Syntax OK')"`
Run: `cd /home/rookslog/workspace/projects/zlibrary-mcp && grep 'cloudflare_blocked' lib/python_bridge.py` — should match
Run: `cd /home/rookslog/workspace/projects/zlibrary-mcp && grep 'network_error' lib/python_bridge.py` — should match
  </verify>
  <done>Health check function classifies errors into cloudflare_blocked, network_error, malformed_response, or unknown_error codes. No httpx imports added.</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for Cloudflare detection in health check</name>
  <files>__tests__/python/test_python_bridge.py</files>
  <action>
Add test cases for the enhanced health check. Find the existing health check tests (search for "health" in test file) and add alongside them:

1. `test_health_check_detects_cloudflare`: Mock the EAPI client to raise an exception containing "Checking your browser" text (use plain `Exception("Checking your browser")`). Assert response has `error_code: "cloudflare_blocked"` and `status: "unhealthy"`.

2. `test_health_check_detects_network_error`: Mock the EAPI client to raise `ConnectionError("Connection refused")` (built-in Python type, NOT httpx). Assert response has `error_code: "network_error"`.

3. `test_health_check_detects_malformed_response`: Mock the EAPI client to return `{'success': 0}` (no books list). Assert response has `error_code: "malformed_response"` or status unhealthy.

Use `unittest.mock.patch` or `pytest-mock` to mock `get_eapi_client` to return a mock client whose `.search()` raises the appropriate exceptions. Use ONLY built-in exception types — no httpx imports in tests.
  </action>
  <verify>
Run: `cd /home/rookslog/workspace/projects/zlibrary-mcp && uv run pytest __tests__/python/test_python_bridge.py -k "health" -v --tb=short`
  </verify>
  <done>Three new health check tests pass: Cloudflare detection, network error detection, malformed response detection. No httpx imports in test file.</done>
</task>

</tasks>

<verification>
- `grep 'cloudflare_blocked' lib/python_bridge.py` returns matches
- `grep 'error_code' lib/python_bridge.py` returns matches in health check function
- `grep -c 'import httpx' lib/python_bridge.py __tests__/python/test_python_bridge.py` — no new httpx imports added
- `uv run pytest __tests__/python/test_python_bridge.py -k "health" -v` — all health check tests pass
- `uv run pytest __tests__/python/ -k "not integration" --tb=short` — no regressions
</verification>

<success_criteria>
Health check returns specific error_code field for all failure modes. Cloudflare challenge patterns are detected using string matching only. Network errors caught via built-in Python exception types. Three new unit tests validate the detection logic. No httpx imports added.
</success_criteria>

<output>
After completion, create `.planning/phases/07-eapi-migration/07-06-SUMMARY.md`
</output>
