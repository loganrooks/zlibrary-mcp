---
phase: 12-annas-archive
plan: 03
type: tdd
wave: 2
depends_on: ["12-01"]
files_modified:
  - lib/sources/libgen.py
  - __tests__/python/test_libgen_adapter.py
autonomous: true

must_haves:
  truths:
    - "LibGen search returns UnifiedBookResult list with source=LIBGEN"
    - "LibGen adapter wraps sync library calls in asyncio.to_thread()"
    - "Download URL extracted from tor_download_link or mirrors"
    - "Rate limiting implemented with MIN_REQUEST_INTERVAL"
  artifacts:
    - path: "lib/sources/libgen.py"
      provides: "LibgenAdapter implementing SourceAdapter"
      exports: ["LibgenAdapter"]
      min_lines: 60
    - path: "__tests__/python/test_libgen_adapter.py"
      provides: "TDD tests for LibGen adapter"
      contains: "test_search_returns_results"
  key_links:
    - from: "lib/sources/libgen.py"
      to: "libgen_api_enhanced"
      via: "Uses LibgenSearch for search"
      pattern: "from libgen_api_enhanced import LibgenSearch"
    - from: "lib/sources/libgen.py"
      to: "lib/sources/models.py"
      via: "Returns UnifiedBookResult and DownloadResult"
      pattern: "from .models import"
---

<objective>
Create LibGen source adapter using libgen-api-enhanced library with async wrapper.

Purpose: Provide fallback book source when Anna's Archive quota is exhausted or unavailable. LibGen has no quota limits.
Output: lib/sources/libgen.py with LibgenAdapter class passing TDD tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-annas-archive/12-CONTEXT.md
@.planning/phases/12-annas-archive/12-RESEARCH.md
@.planning/phases/12-annas-archive/12-EXPERIMENT.md
@.planning/phases/12-annas-archive/12-01-SUMMARY.md
</context>

<feature>
  <name>LibGen Adapter</name>
  <files>lib/sources/libgen.py, __tests__/python/test_libgen_adapter.py</files>
  <behavior>
LibgenAdapter provides:

1. search(query) -> List[UnifiedBookResult]:
   - Uses libgen-api-enhanced LibgenSearch.search_title()
   - CRITICAL: Import is `from libgen_api_enhanced import LibgenSearch` (NOT libgen_api)
   - Wraps sync call in asyncio.to_thread() to avoid blocking
   - Implements rate limiting (MIN_REQUEST_INTERVAL = 2.0 seconds)
   - Returns UnifiedBookResult with source=SourceType.LIBGEN

2. get_download_url(md5) -> DownloadResult:
   - Searches by MD5 to find book
   - Extracts download URL from tor_download_link or mirrors
   - Returns DownloadResult with no quota_info (LibGen has no quota)

Test cases (inputs -> expected outputs):
- search("python programming") -> List with at least 1 UnifiedBookResult
- search("nonexistent_book_xyz123") -> Empty list
- get_download_url("validmd5") -> DownloadResult with URL
- Rate limiting: second search waits MIN_REQUEST_INTERVAL
  </behavior>
  <implementation>
```python
import asyncio
import time
from typing import List, Optional
from .models import UnifiedBookResult, DownloadResult, SourceType
from .base import SourceAdapter
from .config import SourceConfig

# CRITICAL: Import is libgen_api_enhanced, NOT libgen_api
from libgen_api_enhanced import LibgenSearch

class LibgenAdapter(SourceAdapter):
    MIN_REQUEST_INTERVAL = 2.0  # seconds between requests

    def __init__(self, config: SourceConfig):
        self.config = config
        self.mirror = config.libgen_mirror
        self._last_request = 0.0

    async def _rate_limit(self) -> None:
        """Enforce rate limiting between requests."""
        elapsed = time.time() - self._last_request
        if elapsed < self.MIN_REQUEST_INTERVAL:
            await asyncio.sleep(self.MIN_REQUEST_INTERVAL - elapsed)
        self._last_request = time.time()

    async def search(self, query: str, **kwargs) -> List[UnifiedBookResult]:
        await self._rate_limit()

        def _search_sync():
            s = LibgenSearch(mirror=self.mirror)
            return s.search_title(query)

        results = await asyncio.to_thread(_search_sync)

        if not results:
            return []

        return [
            UnifiedBookResult(
                md5=getattr(book, 'md5', '') or '',
                title=getattr(book, 'title', '') or '',
                author=getattr(book, 'author', '') or '',
                year=str(getattr(book, 'year', '') or ''),
                extension=getattr(book, 'extension', '') or '',
                size=getattr(book, 'size', '') or '',
                source=SourceType.LIBGEN,
                download_url=getattr(book, 'tor_download_link', '') or '',
                extra={
                    "id": getattr(book, 'id', ''),
                    "language": getattr(book, 'language', ''),
                    "pages": getattr(book, 'pages', ''),
                },
            )
            for book in results
        ]

    async def get_download_url(self, md5: str) -> DownloadResult:
        await self._rate_limit()

        def _search_by_md5():
            s = LibgenSearch(mirror=self.mirror)
            # LibGen doesn't have direct MD5 lookup, search by MD5 as query
            results = s.search_title(md5)
            for book in results:
                if getattr(book, 'md5', '').lower() == md5.lower():
                    return book
            return None

        book = await asyncio.to_thread(_search_by_md5)

        if not book:
            raise ValueError(f"Book with MD5 {md5} not found in LibGen")

        download_url = getattr(book, 'tor_download_link', '') or ''
        if not download_url:
            # Try mirrors if tor link not available
            mirrors = getattr(book, 'mirrors', {})
            if mirrors:
                download_url = list(mirrors.values())[0] if isinstance(mirrors, dict) else str(mirrors)

        if not download_url:
            raise ValueError(f"No download URL found for book {md5}")

        return DownloadResult(
            url=download_url,
            source=SourceType.LIBGEN,
            quota_info=None,  # LibGen has no quota
        )

    async def close(self) -> None:
        # LibgenSearch doesn't maintain persistent connections
        pass
```
  </implementation>
</feature>

<verification>
```bash
# Run TDD tests
cd /home/rookslog/workspace/projects/zlibrary-mcp && uv run pytest __tests__/python/test_libgen_adapter.py -v

# Quick integration check
cd /home/rookslog/workspace/projects/zlibrary-mcp && uv run python -c "
import asyncio
from lib.sources.libgen import LibgenAdapter
from lib.sources.config import get_source_config

async def test():
    config = get_source_config()
    adapter = LibgenAdapter(config)
    try:
        results = await adapter.search('python')
        print(f'Search returned {len(results)} results')
        if results:
            print(f'First: {results[0].md5[:8]}... {results[0].title[:40]}')
    finally:
        await adapter.close()

asyncio.run(test())
"
```
</verification>

<success_criteria>
1. LibgenAdapter implements SourceAdapter interface
2. search() returns List[UnifiedBookResult] with source=LIBGEN
3. get_download_url() returns DownloadResult with URL from tor_download_link
4. Sync LibgenSearch calls wrapped in asyncio.to_thread()
5. Rate limiting enforced between requests
6. TDD tests pass for search and download
</success_criteria>

<output>
After completion, create `.planning/phases/12-annas-archive/12-03-SUMMARY.md`
</output>
